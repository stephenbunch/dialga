{
  "version": 3,
  "sources": [
    "../arceus/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "/Users/stephen/code/stephenbunch/dialga/src/DailyEngine.js",
    "/Users/stephen/code/stephenbunch/dialga/src/Mask.js",
    "/Users/stephen/code/stephenbunch/dialga/src/MonthEngine.js",
    "/Users/stephen/code/stephenbunch/dialga/src/MonthNthEngine.js",
    "/Users/stephen/code/stephenbunch/dialga/src/MonthlyEngine.js",
    "/Users/stephen/code/stephenbunch/dialga/src/Pattern.js",
    "/Users/stephen/code/stephenbunch/dialga/src/WeeklyEngine.js",
    "/Users/stephen/code/stephenbunch/dialga/src/YearNthEngine.js",
    "/Users/stephen/code/stephenbunch/dialga/src/YearlyEngine.js",
    "/Users/stephen/code/stephenbunch/dialga/src/days.js",
    "/Users/stephen/code/stephenbunch/dialga/src/errors/InvalidDateError.js",
    "/Users/stephen/code/stephenbunch/dialga/src/errors/InvalidMaskError.js",
    "/Users/stephen/code/stephenbunch/dialga/src/errors/InvalidOperationError.js",
    "/Users/stephen/code/stephenbunch/dialga/src/errors/InvalidPatternError.js",
    "/Users/stephen/code/stephenbunch/dialga/src/index.js",
    "/Users/stephen/code/stephenbunch/dialga/src/type.js",
    "/Users/stephen/code/stephenbunch/dialga/src/util.js"
  ],
  "names": [],
  "mappings": "AAAA;obCAA,MAAA,QAAA,UAMqB,uBACnB,QAAA,GAAY,GAAS,gBAAA,KAAA,GACnB,KAAK,UAAY,EAAQ,SACzB,KAAK,WAAa,EAAQ,WAC1B,KAAK,kBAAmB,EAAA,MAAA,SAAQ,EAAQ,YACxC,KAAK,gBAAkB,EAAQ,UAAW,EAAA,MAAA,SAAQ,EAAQ,UAAY,mEAQvD,EAAM,GACrB,GAAI,IAAY,EAAA,MAAA,gBAAe,EAAO,KAAK,kBAAoB,KAAK,UAChE,GAAa,EAAA,MAAA,UAAS,EAAM,EAAY,EAO5C,OANI,GAAa,KAAK,mBACpB,EAAa,KAAK,kBAEhB,KAAK,iBAAmB,EAAa,KAAK,kBAC5C,EAAa,KAAK,iBAEb,+BAQJ,EAAY,GACf,OAAO,EAAA,MAAA,UAAS,EAAY,KAAK,UAAY,2CAQ/B,GACd,GAAI,IAAO,EAAA,MAAA,gBAAe,GAAO,EAAA,MAAA,SAAQ,KAAK,YAC9C,OAAO,GAAO,KAAK,YAAc,8BAzChB;;;8fCNrB,kBAAA,QAAA,0FACA,MAAA,QAAA,UASqB,gBAOnB,QAAA,GAAY,GAIV,GAJgB,gBAAA,KAAA,GAChB,KAAK,MAAQ,GAAQ,GACrB,KAAK,WAAa,KAEd,KAAK,MAAO,CACd,GAAI,GAAQ,KAAK,MAAM,MAAM,IAC7B,IAAqB,IAAjB,EAAM,OACR,KAAM,IAAA,oBAAA,WAAqB,mEAAqE,KAAK,MAAQ,KAI/G,KAFA,EAAA,MAAA,cAAa,EAAM,IACnB,KAAK,WAAa,EAAM,GACJ,MAAhB,EAAM,GAAG,GACX,KAAM,IAAA,oBAAA,WAAqB,8DAE7B,IAAsC,MAAlC,EAAM,GAAG,EAAM,GAAG,OAAS,GAC7B,KAAM,IAAA,oBAAA,WAAqB,oHAM/B,MAAO,MAAK,8CAIZ,MAAO,MAAK,iCAOX,GACD,MAAO,MAAK,IAAI,EAAM,SAAC,EAAG,GACxB,MAAO,SAAQ,OAAO,IAAM,QAAQ,OAAO,kCAQ3C,GACF,MAAO,MAAK,IAAI,EAAM,SAAC,EAAG,GACxB,MAAO,SAAQ,OAAO,IAAM,QAAQ,OAAO,kCAQ3C,GACF,MAAO,MAAK,IAAI,EAAM,SAAC,EAAG,GACxB,MAAO,SAAQ,OAAO,IAAM,QAAQ,OAAO,kCAQ3C,GACF,MAAO,MAAK,IAAI,EAAM,SAAC,EAAG,GACxB,MAAI,SAAQ,OAAO,IACV,EAEA,OAAO,QAAQ,OAAO,uCAS3B,GACN,IAAK,KAAK,MACR,OAAO,CAET,IAAI,GAAS,KAAK,MAAM,MAAM,KAC1B,EAAQ,EAAO,EACnB,IAAW,EAAP,EACF,OAAO,CAET,IAAI,IAAQ,EAAA,MAAA,iBAAe,EAAA,MAAA,SAAQ,IAAQ,EAAA,MAAA,SAAQ,GACnD,OAA4B,MAArB,EAAO,GAAG,sCAOjB,IAAK,KAAK,MACR,QAEF,IAAI,MACA,EAAS,KAAK,MAAM,MAAM,KAC1B,EAAQ,EAAO,EACnB,GAAM,KAAK,GACX,GAAQ,EAAA,MAAA,SAAQ,EAGhB,KAAK,GAFD,GAAO,EAAO,GAAG,MAAM,IACvB,EAAS,EAAK,OACT,EAAI,EAAO,EAAJ,EAAY,IACV,MAAZ,EAAK,IACP,EAAM,MAAK,EAAA,MAAA,YAAU,EAAA,MAAA,UAAS,EAAO,IAGzC,OAAO,sCAOP,IAAK,KAAK,MACR,MAAO,KAET,IAAI,GAAS,KAAK,MAAM,MAAM,KAC1B,GAAQ,EAAA,MAAA,SAAQ,EAAO,IACvB,GAAM,EAAA,MAAA,UAAS,EAAO,EAAO,GAAG,OAAS,EAC7C,SAAQ,EAAA,MAAA,WAAU,IAAQ,EAAA,MAAA,WAAU,oCAO9B,GACN,MAAO,MAAK,GAAG,EAAO,yCAOb,GACT,MAAO,MAAK,IAAI,EAAO,yCAQd,EAAM,GACf,MAAc,UAAV,EACE,KAAK,QAAQ,GACR,KAAK,WAAW,GAEhB,KAAK,QAAQ,GAGlB,EACK,KAAK,QAAQ,GAEb,KAAK,WAAW,+BAKzB,EAAM,GACR,GAAI,GAAQ,EAAK,YAAY,KAAK,MAAO,EACzC,KAAK,EAAM,GACT,MAAO,IAAI,EAMb,KAAK,GAJD,GAAI,EAAM,GAAG,MAAM,KAAK,GAAG,MAAM,IACjC,EAAI,EAAM,GAAG,MAAM,KAAK,GAAG,MAAM,IACjC,KACA,EAAS,EAAE,OACN,EAAI,EAAO,EAAJ,EAAY,IAC1B,EAAO,GAAK,EAAG,EAAE,GAAI,EAAE,GAEzB,OAAO,IAAI,GAAK,EAAK,KAAK,EAAM,GAAG,MAAM,KAAK,GAAK,IAAM,EAAO,KAAK,MAAM,uCAO5D,GACf,IAAK,IAAU,EAAM,OACnB,MAAO,IAAI,EAEb,GAAQ,EAAM,QAAQ,MAItB,KAAK,GAHD,GAAQ,EAAM,GACd,EAAO,IACP,EAAS,EAAM,OACV,EAAI,EAAO,EAAJ,EAAY,IAC1B,IAAQ,EAAA,MAAA,QAAO,KAAK,EAAA,MAAA,iBAAe,EAAA,MAAA,SAAQ,EAAM,KAAM,EAAA,MAAA,SAAQ,EAAM,EAAI,KAAO,GAChF,GAAQ,GAEV,OAAO,IAAI,GAAK,EAAQ,IAAM,gCASpB,GACV,GAAK,GAA8B,KAAtB,EAAK,QAAQ,KAEnB,CACL,GAAI,GAAQ,EAAK,MAAM,KACnB,EAAQ,EAAM,GACd,EAAQ,EAAM,EAClB,OAA2B,KAAvB,EAAM,QAAQ,KACT,GACe,MAAb,EAAM,IAA0C,MAA5B,EAAM,EAAM,OAAS,GAC3C,GAEP,GAAQ,EAAA,MAAA,YAAU,EAAA,MAAA,WAAS,EAAA,MAAA,SAAQ,GAAQ,EAAM,QAAQ,OACzD,EAAQ,EAAM,UAAU,EAAM,QAAQ,KAAM,EAAM,YAAY,KAAO,GAC9D,EAAQ,IAAM,GAZvB,MAAO,uCAyBQ,EAAO,GACxB,EAAQ,GAAS,EAAM,WACvB,EAAQ,GAAS,EAAM,UACvB,IAAI,KAAM,GAAS,EAAM,MAAM,KAC3B,IAAM,GAAS,EAAM,MAAM,IAC/B,KAAK,IAAM,EACT,OAAQ,GAAI,GAET,GAEQ,IACX,GAAK,EAAE,IAAI,EAAA,MAAA,QAAO,IAAK,EAAE,GAAG,UAF5B,GAAK,EAAE,IAAI,EAAA,MAAA,QAAO,IAAK,EAAE,GAAG,QAI9B,IAAI,GAAA,MAkBJ,OAjBI,GAAE,GAAK,EAAE,IACX,GAAO,EAAA,MAAA,iBAAe,EAAA,MAAA,SAAQ,EAAE,KAAM,EAAA,MAAA,SAAQ,EAAE,KAChD,EAAE,KAAM,EAAA,MAAA,QAAO,IAAK,GACpB,EAAE,IAAK,EAAA,MAAA,QAAO,IAAK,GAAQ,EAAE,GAC7B,EAAE,GAAK,EAAE,IACA,EAAE,GAAK,EAAE,KAClB,GAAO,EAAA,MAAA,iBAAe,EAAA,MAAA,SAAQ,EAAE,KAAM,EAAA,MAAA,SAAQ,EAAE,KAChD,EAAE,KAAM,EAAA,MAAA,QAAO,IAAK,GACpB,EAAE,IAAK,EAAA,MAAA,QAAO,IAAK,GAAQ,EAAE,GAC7B,EAAE,GAAK,EAAE,IAEP,EAAE,GAAG,OAAS,EAAE,GAAG,SACrB,EAAE,KAAM,EAAA,MAAA,QAAO,IAAK,EAAE,GAAG,OAAS,EAAE,GAAG,SAErC,EAAE,GAAG,OAAS,EAAE,GAAG,SACrB,EAAE,KAAM,EAAA,MAAA,QAAO,IAAK,EAAE,GAAG,OAAS,EAAE,GAAG,UAEjC,EAAE,KAAK,KAAM,EAAE,KAAK,kCA1QX;;;obCVrB,MAAA,QAAA,UAOqB,uBACnB,QAAA,GAAA,GAA+C,GAAjC,GAAiC,EAAjC,MAAO,EAA0B,EAA1B,IAAK,EAAqB,EAArB,SAAU,EAAW,EAAX,OAAW,iBAAA,KAAA,GAC7C,KAAK,UAAY,EACjB,KAAK,SAAW,CAEhB,IAAI,IAAe,EAAA,MAAA,SAAQ,GACvB,GAAO,EAAA,MAAA,SAAQ,GACf,GAAQ,EAAA,MAAA,UAAS,GACjB,EAAkB,KAAK,aAAa,EAAM,EACxB,GAAlB,IACF,EAAkB,KAAK,aAAa,EAAM,EAAQ,IAEpD,KAAK,gBAAkB,EAEnB,EACF,KAAK,eAAiB,KAAK,qBAAoB,EAAA,MAAA,SAAQ,IAEvD,KAAK,eAAiB,mEAST,EAAM,GACrB,GAAI,GAAa,KAAK,oBAAoB,EAW1C,OAViB,GAAb,GAAqB,EAAY,EACnC,EAAa,KAAK,cAAa,EAAA,MAAA,SAAQ,IAAa,EAAA,MAAA,UAAS,GAAc,KAAK,WACvE,EAAa,GAAoB,EAAZ,IAC9B,EAAa,KAAK,cAAa,EAAA,MAAA,SAAQ,IAAa,EAAA,MAAA,UAAS,GAAc,KAAK,YAE9E,EAAa,KAAK,gBACpB,EAAa,KAAK,gBACT,KAAK,gBAAkB,EAAa,KAAK,iBAClD,EAAa,KAAK,gBAEb,+BAQJ,EAAY,GACf,MAAO,MAAK,cAAa,EAAA,MAAA,SAAQ,IAAa,EAAA,MAAA,UAAS,GAAe,KAAK,UAAY,+CAOrE,GAClB,GAAI,EAAO,KAAK,gBACd,MAAO,MAAK,eAEd,IAAI,GAAS,KAAK,OAAM,EAAA,MAAA,kBAAiB,KAAK,gBAAiB,GAAQ,KAAK,WAAa,KAAK,UAC1F,EAAa,KAAK,cAAa,EAAA,MAAA,SAAQ,KAAK,kBAAkB,EAAA,MAAA,UAAS,KAAK,iBAAmB,EAOnG,OANI,GAAa,IACf,EAAa,KAAK,cAAa,EAAA,MAAA,SAAQ,IAAa,EAAA,MAAA,UAAS,GAAc,KAAK,YAE9E,EAAa,KAAK,kBACpB,EAAa,KAAK,iBAEb,uCAQI,EAAM,GAQjB,MAPI,GAAQ,IACV,GAAQ,KAAK,MAAM,EAAQ,IAC3B,GAAkC,GAAzB,KAAK,MAAM,EAAQ,KACX,EAAR,IACT,GAAQ,KAAK,KAAmB,IAAb,EAAQ,GAAU,IACrC,GAA4C,GAAnC,KAAK,KAAmB,IAAb,EAAQ,GAAU,KAEjC,KAAK,SAAS,EAAM,+BAlFV;;;8fCPrB,MAAA,QAAA,UAQA,aAAA,QAAA,oEAEqB,0BACnB,QAAA,GAAY,GAAS,GAAA,GAAA,IAAA,iBAAA,KAAA,GACnB,KAAK,YAAa,EAAA,MAAA,mBAAkB,EAAQ,kBAC5C,KAAK,UAAY,EAAQ,SACzB,KAAK,UAAY,EAAQ,SACzB,KAAK,QAAU,GAAA,eAAA,YACb,MAAO,EAAQ,WACf,IAAK,EAAQ,SACb,SAAU,KAAK,UACf,QAAS,SAAC,EAAM,GAAP,OAAiB,EAAA,MAAA,qBAAoB,EAAM,EAAO,EAAK,UAAW,EAAK,6EAInE,EAAM,GACrB,MAAO,MAAK,QAAQ,iBAAiB,EAAM,gCAGxC,EAAY,GACf,MAAO,MAAK,QAAQ,KAAK,EAAY,2CAGvB,GACd,OACE,EAAA,MAAA,cAAa,KAAU,KAAK,aAC5B,EAAA,MAAA,aAAY,KAAU,KAAK,YAC3B,EAAA,MAAA,kBAAiB,EAAM,KAAK,QAAQ,iBAAmB,KAAK,YAAc,8BAzB3D;;;8fCVrB,MAAA,QAAA,UAOA,aAAA,QAAA,oEAEqB,yBACnB,QAAA,GAAY,GAAS,gBAAA,KAAA,GACnB,KAAK,UAAY,EAAQ,SACzB,KAAK,KAAO,EAAQ,aACpB,KAAK,QAAU,GAAA,eAAA,YACb,MAAO,EAAQ,WACf,IAAK,EAAQ,SACb,SAAU,EAAQ,SAClB,QAAS,SAAC,EAAM,GAAP,OAAiB,EAAA,MAAA,aAAY,EAAM,EAAO,EAAQ,+EAS9C,EAAM,GACrB,MAAO,MAAK,QAAQ,iBAAiB,EAAM,gCAQxC,EAAY,GACf,MAAO,MAAK,QAAQ,KAAK,EAAY,2CAQvB,GACd,QACG,EAAA,MAAA,cAAY,EAAA,MAAA,SAAQ,IAAO,EAAA,MAAA,UAAS,GAAO,KAAK,SAAW,IAC5D,EAAA,MAAA,kBAAiB,KAAK,QAAQ,gBAAiB,GAAQ,KAAK,YAAc,8BAtC3D;;;yqBCTrB,MAAA,QAAA,+CAEA,MAAA,QAAA,UAaA,qBAAA,QAAA,mGACA,uBAAA,QAAA,yGAEA,MAAA,QAAA,+CAEA,aAAA,QAAA,oEACA,cAAA,QAAA,uEACA,eAAA,QAAA,0EACA,gBAAA,QAAA,6EACA,cAAA,QAAA,uEACA,eAAA,QAAA,0EAEqB,mBAInB,QAAA,GAAY,GAAS,gBAAA,KAAA,GACnB,KAAK,MAAL,UACE,WAAY,KACZ,SAAU,KACV,KAAM,KACN,iBAAkB,KAClB,aAAc,KACd,cAAe,KACf,SAAU,KACV,SAAU,KACV,eACG,GAEL,KAAK,YAAa,0DAOlB,MAAI,MAAK,WACA,MAET,KAAK,kBACL,KAAK,gBACL,KAAK,yBACL,KAAK,oBACL,KAAK,sBACL,KAAK,YAAa,EACX,sCAOW,GAAd,GAAc,UAAA,QAAA,GAAA,SAAA,UAAA,GAAH,EAAG,UAAA,EAGlB,OAFA,MAAK,YAAa,EAClB,KAAK,MAAM,SAAW,EACf,iCAOL,GACF,MAAmB,UAAf,EACK,KAAK,QAEZ,KAAK,YAAa,EAClB,KAAK,MAAM,SAAW,KACtB,KAAK,MAAM,aAAe,EACnB,qCAYT,MAJA,MAAK,YAAa,EAClB,KAAK,MAAM,KAAO,OAAA,WAAK,MACvB,KAAK,MAAM,iBAAmB,KAC9B,KAAK,MAAM,SAAW,KACf,oCASP,MAFA,MAAK,YAAa,EAClB,KAAK,MAAM,KAAO,OAAA,WAAK,OAChB,qCAOP,MAAO,MAAK,uCAcZ,MAPA,MAAK,YAAa,EACd,KAAK,MAAM,SACb,KAAK,MAAM,KAAO,OAAA,WAAK,UAEvB,KAAK,MAAM,KAAO,OAAA,WAAK,QACvB,KAAK,MAAM,iBAAmB,MAEzB,sCAOP,MAAO,MAAK,uCAcZ,MAPA,MAAK,YAAa,EACd,KAAK,MAAM,SACb,KAAK,MAAM,KAAO,OAAA,WAAK,SAEvB,KAAK,MAAM,KAAO,OAAA,WAAK,OACvB,KAAK,MAAM,iBAAmB,MAEzB,qCAOP,MAAO,MAAK,kCAOX,GAID,MAHA,MAAK,YAAa,EAClB,KAAK,MAAM,iBAAmB,EAC9B,KAAK,MAAM,SAAW,KACf,iCAQL,EAAU,GAIZ,MAHA,MAAK,YAAa,EAClB,KAAK,MAAM,SAAW,EACtB,KAAK,MAAM,iBAAmB,EACvB,kCAOJ,GAGH,MAFA,MAAK,YAAa,EAClB,KAAK,MAAM,WAAa,EACjB,gCAON,GAGD,MAFA,MAAK,YAAa,EAClB,KAAK,MAAM,SAAW,EACf,0CAQI,EAAM,GACjB,KAAK,YAAa,CAClB,IAAI,IAAY,EAAA,MAAA,MAAK,KAAK,MAAM,WAAY,SAAS,GACnD,MAAO,GAAU,gBAAkB,GAQrC,OANK,KACH,KACA,KAAK,MAAM,WAAW,KAAK,IAE7B,EAAU,cAAgB,EAC1B,EAAU,KAAO,EACV,6CAOO,GACd,KAAK,YAAa,CAClB,IAAI,IAAQ,EAAA,MAAA,WAAU,KAAK,MAAM,WAAY,SAAS,GACpD,MAAO,GAAU,gBAAkB,GAKrC,OAHI,GAAQ,IACV,KAAK,MAAM,WAAW,OAAO,EAAO,GAE/B,mDASP,MAFA,MAAK,YAAa,EAClB,KAAK,MAAM,cACJ,2CAOK,GACZ,OAAO,EAAA,MAAA,MAAK,KAAK,MAAM,WAAY,SAAS,GAC1C,MAAO,GAAU,gBAAkB,oCAS/B,GAEN,MADA,MAAK,WACD,KAAK,kBAAkB,IAClB,EAEL,KAAK,OAAO,IACP,EAEJ,KAAK,uBAAuB,GAG1B,KAAK,QAAQ,iBAAgB,EAAA,MAAA,SAAQ,KAFnC,mCAUT,MAAO,MAAK,qCAOP,GAEL,GADA,EAAM,GAAO,KAAK,MAAM,UACnB,EACH,KAAM,IAAA,yBAAA,WAA0B,8CAIlC,KAFA,GAAI,GAAO,GACP,EAAA,OAAM,EAAA,QACH,EAAO,KAAK,KAAK,OAClB,EAAO,IADkB,CAI7B,GAAI,IAAO,EAAA,MAAA,iBAAe,EAAA,MAAA,SAAQ,IAAQ,EAAA,MAAA,SAAQ,GAAQ,KAAK,MAAM,YACjE,KACF,GAAQ,GAEV,IAAQ,EAAA,MAAA,QAAO,IAAK,GACpB,GAAQ,IACR,EAAO,EAET,MAAI,GACK,GAAA,QAAA,WAAS,OAAA,WAAK,KAAK,KAAK,MAAM,WAAa,IAAM,IAEjD,GAAA,QAAA,wCAYN,EAAO,GACV,KAAK,WACgB,gBAAV,KACT,EAAY,EACZ,GAAQ,EAAA,MAAA,YAAU,EAAA,MAAA,WAAS,EAAA,MAAA,SAAQ,KAAK,MAAM,YAAa,KAG7D,KADA,GAAI,GAAO,IACE,CAEX,GADA,GAAO,EAAA,MAAA,WAAU,KAAK,oBAAmB,EAAA,MAAA,SAAQ,IAAO,EAAA,MAAA,oBAAmB,MACvE,KAAK,uBAAuB,GAc9B,OAAO,CAZP,IAAI,GAAY,KAAK,0BAA0B,EAC/C,KAAI,EAOF,MAAO,EANP,IAAI,EAAU,KACZ,MAAO,4CAsBD,EAAO,GACrB,KAAK,UACL,IAAI,IAAO,EAAA,MAAA,WAAU,KAAK,oBAAmB,EAAA,MAAA,SAAQ,IAAQ,EAAA,MAAA,oBAAmB,IAChF,OAAI,MAAK,uBAAuB,GACvB,GAEA,+BAWN,EAAM,GAET,MADA,MAAK,YACE,EAAA,MAAA,WAAU,KAAK,mBAAkB,EAAA,MAAA,SAAQ,IAAO,EAAA,MAAA,oBAAmB,+CAI1E,IAAK,KAAK,MAAM,WACd,KAAM,IAAA,uBAAA,WAAwB,4BAIhC,IAFA,KAAK,MAAM,WAAa,OAAO,KAAK,MAAM,aAC1C,EAAA,MAAA,cAAa,KAAK,MAAM,YACpB,KAAK,MAAM,WACb,KAAK,MAAM,SAAW,OAAO,KAAK,MAAM,WACxC,EAAA,MAAA,cAAa,KAAK,MAAM,UACpB,KAAK,MAAM,WAAa,KAAK,MAAM,UACrC,KAAM,IAAA,uBAAA,WAAwB,wGAMlC,IAAK,KAAK,MAAM,KACd,KAAM,IAAA,uBAAA,WAAwB,iCAGhC,QADA,KAAK,MAAM,KAAO,OAAO,KAAK,MAAM,MAC5B,KAAK,MAAM,MACjB,IAAK,QAAA,WAAK,MACR,KAAK,QAAU,GAAA,eAAA,WAAgB,KAAK,MACpC,MACF,KAAK,QAAA,WAAK,OACR,KAAK,QAAU,GAAA,gBAAA,WAAiB,KAAK,MACrC,MACF,KAAK,QAAA,WAAK,QACR,KAAK,QAAU,GAAA,iBAAA,WAAkB,KAAK,MACtC,MACF,KAAK,QAAA,WAAK,SACR,KAAK,QAAU,GAAA,kBAAA,WAAmB,KAAK,MACvC,MACF,KAAK,QAAA,WAAK,OACR,KAAK,QAAU,GAAA,gBAAA,WAAiB,KAAK,MACrC,MACF,KAAK,QAAA,WAAK,QACR,KAAK,QAAU,GAAA,iBAAA,WAAkB,KAAK,MACtC,MACF,SACE,KAAM,IAAA,uBAAA,WAAwB,wBAA0B,KAAK,MAAM,KAAO,mEAK9E,GACE,KAAK,MAAM,OAAS,OAAA,WAAK,QACzB,KAAK,MAAM,OAAS,OAAA,WAAK,UACzB,KAAK,MAAM,OAAS,OAAA,WAAK,QACzB,CACA,IAAK,KAAK,MAAM,iBACd,KAAM,IAAA,uBAAA,WAAwB,wFAEhC,KAAI,KAAK,MAAM,OAAS,OAAA,WAAK,UAAY,KAAK,MAAM,OAAS,OAAA,WAAK,WAC5D,EAAA,MAAA,mBAAkB,KAAK,MAAM,kBAAoB,IAAM,EACzD,KAAM,IAAA,uBAAA,WAAwB,2FAIlC,MAAK,MAAM,iBAAmB,iDAKhC,IAAK,KAAK,MAAM,SACd,KAAM,IAAA,uBAAA,WAAwB,qCAGhC,IADA,KAAK,MAAM,SAAW,OAAO,KAAK,MAAM,UACpC,MAAM,KAAK,MAAM,WAAa,KAAK,MAAM,UAAY,EACvD,KAAM,IAAA,uBAAA,WAAwB,0GAIZ,GAAA,GAAA,IACpB,MAAK,qBACL,KAAK,6BACL,KAAK,UACL,KAAK,MAAM,WAAa,KAAK,MAAM,eAEnC,KAAK,YAAa,CAClB,IAAI,KACJ,KACE,KAAK,MAAM,WAAW,QAAQ,SAAA,GAC5B,IAAK,EAAK,QAAQ,EAAU,eAC1B,KAAM,IAAA,uBAAA,WAAwB,4CAA8C,EAAU,cAAgB,KAExG,IAAI,EAAW,EAAU,eACvB,KAAM,IAAA,uBAAA,WAAwB,uCAAyC,EAAU,cAAgB,KAEnG,IAAI,EAAU,KAAM,CAClB,GACE,EAAU,KAAO,EAAK,MAAM,YAC1B,EAAK,MAAM,UAAY,EAAU,KAAO,EAAK,MAAM,SAErD,KAAM,IAAA,uBAAA,WAAwB,sBAAwB,EAAU,cAAgB,mCAElF,IAAI,EAAU,OAAS,EAAU,eAAiB,EAAK,QAAQ,EAAU,MACvE,KAAM,IAAA,uBAAA,WAAwB,sBAAwB,EAAU,cAAgB,4DAElF,IAAI,EAAW,EAAU,eACvB,KAAM,IAAA,uBAAA,WAAwB,uCAAyC,EAAU,cAAgB,KAEnG,IAAI,EAAU,MAAQ,EAAK,gBAAgB,EAAU,cAAe,IAClE,KAAM,IAAA,uBAAA,WAAwB,sBAAwB,EAAU,cAAgB,8CAElF,IAAI,EAAU,MAAQ,EAAK,gBAAgB,EAAU,cAAe,GAClE,KAAM,IAAA,uBAAA,WAAwB,sBAAwB,EAAU,cAAgB,4CAGpF,EAAW,EAAU,gBAAiB,IA5B1C,QA+BE,KAAK,YAAa,EAGpB,KAAK,MAAM,WAAW,QAAQ,SAAA,GAC5B,EAAK,0BAA0B,EAAU,eAAiB,EACtD,EAAU,gBAAkB,EAAU,OACxC,EAAK,OAAO,EAAU,gBAAiB,GAErC,EAAU,OACZ,EAAK,kBAAkB,EAAU,MAAQ,oDAUxB,GACrB,MACE,IAAQ,KAAK,MAAM,cACjB,KAAK,MAAM,UAAY,GAAQ,KAAK,MAAM,qDAY7B,EAAO,GACxB,GAAI,GAAa,KAAK,kBAAkB,EAAO,EAC/C,QAAK,KAAgB,EACZ,EAEF,KAAK,QAAQ,KAAK,EAAY,6CAYrB,EAAM,GACtB,MAAO,MAAK,QAAQ,iBAAiB,EAAM,+BAjgB1B,SAsgBnB,UAAW,WAAY,QAAS,QAAS,MAAO,OAAQ,OACxD,SAAU,YAAa,UAAW,WAAY,YAC9C,QAAQ,SAAS,EAAO,GACxB,QAAQ,UAAU,EAAM,eAAiB,SAAS,GAOhD,MANA,MAAK,YAAa,EAClB,KAAK,MAAM,cAAgB,EAAQ,EAC/B,IACF,KAAK,MAAM,aAAe,EAC1B,KAAK,MAAM,SAAW,MAEjB,MAGT,QAAQ,UAAU,KAAO,GAAS,SAAS,GAOzC,MANA,MAAK,YAAa,EAClB,KAAK,MAAM,cAAgB,EAAQ,EAC/B,IACF,KAAK,MAAM,aAAe,EAC1B,KAAK,MAAM,SAAW,MAEjB;;;8fCrjBX,MAAA,QAAA,+CACA,MAAA,QAAA,UAWqB,wBACnB,QAAA,GAAY,GAAS,gBAAA,KAAA,GACnB,KAAK,UAAY,EAAQ,SACzB,KAAK,eAAiB,EAAQ,iBAC9B,KAAK,WAAa,EAAQ,WAC1B,KAAK,SAAW,EAAQ,uEAQT,EAAM,GACrB,MAAQ,KAAK,oBAAoB,IAC/B,GAAO,EAAA,MAAA,UAAS,EAAM,EAIxB,KADA,GAAI,IAAW,EAAA,MAAA,SAAQ,KAAK,aACpB,KAAK,oBAAoB,IAC/B,GAAW,EAAA,MAAA,UAAS,EAAU,EAEhC,IAAY,GAAR,EACF,MAAO,EAGT,IAAI,KAAK,SAAU,CAEjB,IADA,GAAI,IAAU,EAAA,MAAA,SAAQ,KAAK,WACnB,KAAK,oBAAoB,IAC/B,GAAU,EAAA,MAAA,UAAS,EAAS,GAE9B,IAAI,GAAQ,EACV,MAAO,GAIX,GAAI,IAAY,EAAA,MAAA,kBAAgB,EAAA,MAAA,WAAU,IAAQ,EAAA,MAAA,WAAU,IAAa,KAAK,SAC9E,IAAI,EAAY,EAAG,CACjB,GAAO,EAAA,MAAA,WAAU,EAAM,EAAY,EACnC,IAAI,IAAW,EAAA,MAAA,sBAAqB,KAAK,eACzC,OAAI,GAAY,GAGP,EAAA,MAAA,WAAS,EAAA,MAAA,WAAU,GAAO,EAAS,KAInC,EAAA,MAAA,WAAS,EAAA,MAAA,YAAU,EAAA,MAAA,WAAU,EAAM,MAAO,EAAI,EAAS,EAAS,OAAS,KAGlF,MAAO,gCASN,EAAY,GACf,EACE,IAAa,EAAA,MAAA,UAAS,EAAY,IAG9B,EAAA,MAAA,kBAAiB,KAAgB,OAAA,WAAK,SACxC,GAAa,EAAA,MAAA,WAAU,GAAa,KAAK,UAAY,GAAK,WAEpD,KAAK,oBAAoB,GACnC,OAAO,2CAQO,GACd,MACE,MAAK,oBAAoB,IACzB,KAAK,yBAAyB,+CASd,GAClB,OAAO,EAAA,MAAA,SAAQ,KAAK,gBAAgB,EAAA,MAAA,kBAAiB,qDAQ9B,GACvB,GAAI,IAAQ,EAAA,MAAA,YAAU,EAAA,MAAA,SAAQ,KAAK,aAC/B,GAAM,EAAA,MAAA,WAAU,GAChB,GAAQ,EAAA,MAAA,iBAAgB,EAAM,EAClC,OAAO,GAAQ,KAAK,YAAc,8BArGjB;;;8fCZrB,MAAA,QAAA,UASA,aAAA,QAAA,oEAEqB,yBACnB,QAAA,GAAY,GAAS,GAAA,GAAA,IAAA,iBAAA,KAAA,GACnB,KAAK,YAAa,EAAA,MAAA,mBAAkB,EAAQ,kBAC5C,KAAK,UAAY,EAAQ,SACzB,KAAK,UAAY,EAAQ,SACzB,KAAK,OAAS,EAAQ,cACtB,KAAK,QAAU,GAAA,eAAA,YACb,MAAO,EAAQ,WACf,IAAK,EAAQ,SACb,SAA6B,GAAnB,EAAQ,SAClB,QAAS,SAAA,GAAA,OAAQ,EAAA,MAAA,qBAAoB,EAAM,EAAQ,cAAe,EAAQ,SAAU,EAAK,6EAI5E,EAAM,GACrB,MAAO,MAAK,QAAQ,iBAAiB,EAAM,gCAGxC,EAAY,GACf,MAAO,MAAK,QAAQ,KAAK,EAAY,2CAGvB,GACd,OACE,EAAA,MAAA,cAAa,KAAU,KAAK,aAC5B,EAAA,MAAA,aAAY,KAAU,KAAK,YAC3B,EAAA,MAAA,UAAS,KAAU,KAAK,SACxB,EAAA,MAAA,iBAAgB,EAAM,KAAK,QAAQ,iBAAmB,KAAK,YAAc,8BA3B1D;;;8fCXrB,MAAA,QAAA,UAOA,aAAA,QAAA,oEAEqB,wBACnB,QAAA,GAAY,GAAS,gBAAA,KAAA,GACnB,KAAK,KAAO,EAAQ,aACpB,KAAK,OAAS,EAAQ,cACtB,KAAK,UAAY,EAAQ,SACzB,KAAK,QAAU,GAAA,eAAA,YACb,MAAO,EAAQ,WACf,IAAK,EAAQ,SACb,SAA6B,GAAnB,EAAQ,SAClB,QAAS,SAAA,GAAA,OAAQ,EAAA,MAAA,aAAY,EAAM,EAAQ,cAAe,EAAQ,+EAIrD,EAAM,GACrB,MAAO,MAAK,QAAQ,iBAAiB,EAAM,gCAGxC,EAAY,GACf,MAAO,MAAK,QAAQ,KAAK,EAAY,2CAGvB,GACd,QACG,EAAA,MAAA,cAAY,EAAA,MAAA,SAAQ,IAAO,EAAA,MAAA,UAAS,GAAO,KAAK,SAAW,IAC5D,EAAA,MAAA,UAAS,KAAU,KAAK,SACxB,EAAA,MAAA,iBAAgB,KAAK,QAAQ,gBAAiB,GAAQ,KAAK,YAAc,8BAzB1D;;;wFCJnB,OAAQ,EACR,OAAQ,EACR,QAAS,EACT,UAAW,EACX,SAAU,GACV,OAAQ,GACR,SAAU,GACV,IAAK,IACL,SAAU,GACV,SAAU;;;8/BCdS,8BACnB,QAAA,GAAY,GAAS,gBAAA,KAAA,EAAA,IAAA,GAAA,2BAAA,KAAA,OAAA,eAAA,GAAA,KAAA,MAAA,OAEnB,GAAK,KAAO,mBACZ,EAAK,QAAU,EAHI,8CADuB,2BAAzB;;;8/BCAA,8BACnB,QAAA,GAAY,GAAS,gBAAA,KAAA,EAAA,IAAA,GAAA,2BAAA,KAAA,OAAA,eAAA,GAAA,KAAA,MAAA,OAEnB,GAAK,KAAO,mBACZ,EAAK,QAAU,EAHI,8CADuB,2BAAzB;;;8/BCAA,mCACnB,QAAA,GAAY,GAAS,gBAAA,KAAA,EAAA,IAAA,GAAA,2BAAA,KAAA,OAAA,eAAA,GAAA,KAAA,MAAA,OAEnB,GAAK,KAAO,wBACZ,EAAK,QAAU,EAHI,8CAD4B,2BAA9B;;;8/BCAA,iCACnB,QAAA,GAAY,GAAS,gBAAA,KAAA,EAAA,IAAA,GAAA,2BAAA,KAAA,OAAA,eAAA,GAAA,KAAA,MAAA,OAEnB,GAAK,KAAO,sBACZ,EAAK,QAAU,EAHI,8CAD0B,2BAA5B;;;6ICArB,IAAA,UAAA,QAAA,wDACA,MAAA,QAAA,+CACA,MAAA,QAAA,+CACA,MAAA,QAAA,+CAEA,kBAAA,QAAA,0FACA,kBAAA,QAAA,0FACA,uBAAA,QAAA,yGACA,qBAAA,QAAA,mGAEI,SAAU,WACZ,MAAO,IAAA,WAAA,WAGT,UAAQ,QAAR,UAAA,WACA,SAAQ,KAAR,OAAA,WACA,SAAQ,KAAR,OAAA,WACA,SAAQ,KAAR,OAAA,WAEA,SAAQ,QACN,iBAAA,mBAAA,WACA,iBAAA,mBAAA,WACA,sBAAA,wBAAA,WACA,oBAAA,sBAAA,+BAGa;;;wFCrBb,MAAO,EACP,OAAQ,EACR,QAAS,EACT,SAAU,EACV,OAAQ,EACR,QAAS;;;uFCFJ,QAAS,SAAQ,GACtB,IAAK,aAAa,KAAK,GACrB,KAAM,IAAA,oBAAA,WAAqB,SAAW,EAAO,kDAE/C,IAAI,GAAS,GAAI,MAAK,EAAO,iBAC7B,IAAI,MAAM,EAAO,WACf,KAAM,IAAA,oBAAA,WAAqB,SAAW,EAAO,gBAE/C,OAAO,GAUF,QAAS,kBAAiB,EAAM,EAAO,GAC5C,MAAO,SAAW,EAAX,IAAmB,QAAQ,GAA3B,IAAqC,QAAQ,IAW/C,QAAS,aAAY,EAAM,EAAO,GACvC,GAAI,GAAc,eAAe,iBAAiB,EAAM,EAAO,GAC/D,OAAO,kBAAiB,EAAM,EAAO,KAAK,IAAI,EAAK,IAG9C,QAAS,aAAY,GAC1B,MAAO,MAAK,KAAK,cAAc,GAAQ,GAUlC,QAAS,qBAAoB,EAAM,EAAO,EAAU,GACzD,GAAI,GAAO,iBAAiB,EAAM,EAAO,GACrC,EAAO,aAAa,EACR,GAAZ,IACF,GAAa,EAEf,IAAI,GAAgB,EAAI,EAAY,EAChC,EAAM,EAAiC,GAAhB,EAAW,GAClC,EAAc,eAAe,EAIjC,OAHI,GAAM,IACR,GAAO,GAEF,iBAAiB,EAAM,EAAO,GAMhC,QAAS,cAAa,GAC3B,QAAQ,GAOH,QAAS,WAAU,GACxB,GAAI,GAAQ,QAAQ,SAAS,IACzB,EAAM,QAAQ,cAAc,GAChC,OAAO,GAAK,iBAAmB,IAAM,EAAQ,IAAM,EAG9C,QAAS,SAAQ,GAKtB,MAJA,GAAQ,EAAM,WACO,IAAjB,EAAM,SACR,EAAQ,IAAM,GAET,EAGF,QAAS,UAAS,GACvB,MAAO,GAAK,cAAgB,EAGvB,QAAS,eAAc,GAC5B,MAAO,GAAK,aAGP,QAAS,SAAQ,GACtB,MAAO,GAAK,iBAGP,QAAS,gBAAe,GAC7B,GAAI,GAAO,QAAQ,GACf,EAAQ,SAAS,GAAQ,CAO7B,OANI,GAAQ,KACV,EAAQ,EACR,GAAQ,GAEV,EAAO,QAAW,EAAX,IAAmB,QAAQ,GAA3B,OACP,EAAO,SAAS,EAAM,IACf,cAAc,GAGhB,QAAS,oBAAmB,GAAM,GAAA,GACd,UAAU,GAAM,MAAM,KADR,EAAA,eAAA,EAAA,GAClC,EADkC,EAAA,GAC5B,EAD4B,EAAA,EAAA,GAAA,EAEvC,OAAO,SAAW,EAAX,IAAmB,EAAnB,OAQF,QAAS,cAAa,GAC3B,MAAO,GAAK,YAOP,QAAS,kBAAiB,GAC/B,MAAO,iBAAgB,aAAa,IAO/B,QAAS,iBAAgB,GAC9B,MAAO,MAAK,IAAI,EAAG,GAOd,QAAS,mBAAkB,GAChC,MAAO,MAAK,IAAI,GAAQ,KAAK,IAAI,GAO5B,QAAS,WAAU,GACxB,MAAO,UAAS,GAAO,aAAa,IAS/B,QAAS,SAAQ,EAAM,GAC5B,OAAQ,EAAO,KAAU,EASpB,QAAS,gBAAe,GAC7B,OAAS,EAAY,IAAO,GAAK,GAAK,GAOjC,QAAS,iBAAgB,GAC9B,MAAO,gBAAe,GAAY,EAG7B,QAAS,kBAAiB,EAAO,GACtC,GAAI,EAAQ,EAAK,CACf,GAAI,GAAO,CACX,GAAM,EACN,EAAQ,EAEV,GAAI,GAAY,QAAQ,GACpB,EAAa,SAAS,GACtB,EAAU,QAAQ,GAClB,EAAW,SAAS,GACpB,EAAQ,EAAU,EAClB,EAAS,CAQb,OAPI,GAAW,EACb,EAAS,EAAW,EACA,EAAX,IACT,EAAS,EAAa,EACtB,GAAS,GAEX,GAAkB,GAAR,EAIL,QAAS,iBAAgB,EAAO,GACrC,MAAO,MAAK,IAAI,QAAQ,GAAO,QAAQ,IAOlC,QAAS,gBAAe,GAC7B,MAAc,IAAP,EAAY,GAAK,GAAK,IAQxB,QAAS,UAAS,EAAM,GAC7B,MAAO,IAAI,OAAM,EAAO,eAAe,IAQlC,QAAS,WAAU,EAAM,GAC9B,MAAO,UAAS,EAAc,EAAR,GAOjB,QAAS,sBAAqB,GACnC,GAAI,IAAQ,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC1B,IAMJ,OALA,GAAK,QAAQ,SAAS,GAChB,QAAQ,EAAM,gBAAgB,KAChC,EAAO,KAAK,KAGT,EAGF,QAAS,oBAAmB,GACjC,MAAmB,GAAZ,EAAgB,GAAK,EAGvB,QAAS,MAAK,EAAO,GAC1B,GAAI,GAAQ,UAAU,EAAO,EAC7B,OAAI,GAAQ,GACH,EAAM,GAEN,KAIJ,QAAS,WAAU,EAAO,GAC/B,IAAK,GAAI,GAAI,EAAG,EAAI,EAAM,OAAQ,IAChC,GAAI,EAAS,EAAM,IACjB,MAAO,EAGX,OAAO,GAGF,QAAS,QAAO,EAAQ,GAE7B,IAAK,GADD,GAAM,GACD,EAAI,EAAO,EAAJ,EAAW,IACzB,GAAO,CAET,OAAO,+fAtRO,QAAA,gBAkBA,iBAAA,yBAYA,YAAA,oBAKA,YAAA,oBAWA,oBAAA,4BAkBA,aAAA,qBAQA,UAAA,kBAMA,QAAA,gBAQA,SAAA,iBAIA,cAAA,sBAIA,QAAA,gBAIA,eAAA,uBAYA,mBAAA,2BAUA,aAAA,qBAQA,iBAAA,yBAQA,gBAAA,wBAQA,kBAAA,0BAQA,UAAA,kBAUA,QAAA,gBAUA,eAAA,uBAQA,gBAAA,wBAIA,iBAAA,yBAsBA,gBAAA,wBAQA,eAAA,uBASA,SAAA,iBASA,UAAA,kBAQA,qBAAA,6BAWA,mBAAA,2BAIA,KAAA,aASA,UAAA,kBASA,OAAA,MAzRhB,IAAA,mBAAA,QAAA,0FAEM,aAAe",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "import {\n  durationToDays,\n  getDate,\n  plusDays,\n} from './util';\n\nexport default class DailyEngine {\n  constructor(pattern) {\n    this._interval = pattern.interval;\n    this._startDate = pattern.start_date;\n    this._firstOccurrence = getDate(pattern.start_date);\n    this._lastOccurrence = pattern.end_date ? getDate(pattern.end_date) : null;\n  }\n\n  /**\n   * @param {Date} date\n   * @param {Number} direction\n   * @returns {Date}\n   */\n  snapToOccurrence(date, direction) {\n    let remainder = durationToDays(date - this._firstOccurrence) % this._interval;\n    let occurrence = plusDays(date, remainder * direction);\n    if (occurrence < this._firstOccurrence) {\n      occurrence = this._firstOccurrence;\n    }\n    if (this._lastOccurrence && occurrence > this._lastOccurrence) {\n      occurrence = this._lastOccurrence;\n    }\n    return occurrence;\n  }\n\n  /**\n   * @param {Date} occurrence\n   * @param {Number} direction\n   * @returns {Date}\n   */\n  next(occurrence, direction) {\n    return plusDays(occurrence, this._interval * direction);\n  }\n\n  /**\n   * Gets a value indicating whether the date falls on the pattern interval.\n   * @param {Date} date\n   * @returns {Boolean}\n   */\n  matchesInterval(date) {\n    let days = durationToDays(date - getDate(this._startDate));\n    return days % this._interval === 0;\n  }\n};\n",
    "import InvalidMaskError from './errors/InvalidMaskError';\nimport {\n  durationToDays,\n  getDate,\n  getString,\n  plusDays,\n  repeat,\n  validateDate\n} from './util';\n\nexport default class Mask {\n  /**\n   * A mask contains a start date and a series of 1s and 0s where a 1 represents\n   * an occurrence. A mask always starts and ends with a 1. It may also contain a\n   * single 1 if there is only one occurrence.\n   * @param {String} mask\n   */\n  constructor(mask) {\n    this.value = mask || '';\n    this.start_date = null;\n\n    if (this.value) {\n      let parts = this.value.split('|');\n      if (parts.length !== 2) {\n        throw new InvalidMaskError('Mask is invalid. Expected format [yyyy-mm-dd]|[mask] but found \"' + this.value + '\".');\n      }\n      validateDate(parts[0]);\n      this.start_date = parts[0];\n      if (parts[1][0] !== '1') {\n        throw new InvalidMaskError('Mask format is invalid. Mask value should begin with a \"1\".');\n      }\n      if (parts[1][parts[1].length - 1] !== '1') {\n        throw new InvalidMaskError('Mask format is invalid. Mask value should end with a \"1\".');\n      }\n    }\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  /**\n   * @param {Mask|String} mask\n   * @returns {Mask}\n   */\n  or(mask) {\n    return this._op(mask, (a, b) => {\n      return Boolean(Number(a)) | Boolean(Number(b));\n    });\n  }\n\n  /**\n   * @param {Mask|String} mask\n   * @returns {Mask}\n   */\n  and(mask) {\n    return this._op(mask, (a, b) => {\n      return Boolean(Number(a)) & Boolean(Number(b));\n    });\n  }\n\n  /**\n   * @param {Mask|String} mask\n   * @returns {Mask}\n   */\n  xor(mask) {\n    return this._op(mask, (a, b) => {\n      return Boolean(Number(a)) ^ Boolean(Number(b));\n    });\n  }\n\n  /**\n   * @param {Mask|String} mask\n   * @returns {Mask}\n   */\n  not(mask) {\n    return this._op(mask, (a, b) => {\n      if (Boolean(Number(b))) {\n        return 0;\n      } else {\n        return Number(Boolean(Number(a)));\n      }\n    });\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Boolean}\n   */\n  matches(date) {\n    if (!this.value) {\n      return false;\n    }\n    let values = this.value.split('|');\n    let start = values[0];\n    if (date < start) {\n      return false;\n    }\n    let index = durationToDays(getDate(date) - getDate(start));\n    return values[1][index] === '1';\n  }\n\n  /**\n   * @returns {Array.<String>}\n   */\n  getDates() {\n    if (!this.value) {\n      return [];\n    }\n    let dates = [];\n    let values = this.value.split('|');\n    let start = values[0];\n    dates.push(start);\n    start = getDate(start);\n    let days = values[1].split('');\n    let length = days.length;\n    for (let i = 1; i < length; i++) {\n      if (days[i] === '1') {\n        dates.push(getString(plusDays(start, i)));\n      }\n    }\n    return dates;\n  }\n\n  /**\n   * @returns {Array.<String>|null}\n   */\n  getRange() {\n    if (!this.value) {\n      return null;\n    }\n    let values = this.value.split('|');\n    let start = getDate(values[0]);\n    let end = plusDays(start, values[1].length - 1);\n    return [getString(start), getString(end)];\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Mask}\n   */\n  addDate(date) {\n    return this.or(date + '|1');\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Mask}\n   */\n  removeDate(date) {\n    return this.not(date + '|1');\n  }\n\n  /**\n   * @param {String} date\n   * @param {Boolean} [state]\n   * @returns {Mask}\n   */\n  toggleDate(date, state) {\n    if (state === undefined) {\n      if (this.matches(date)) {\n        return this.removeDate(date);\n      } else {\n        return this.addDate(date);\n      }\n    } else {\n      if (state) {\n        return this.addDate(date);\n      } else {\n        return this.removeDate(date);\n      }\n    }\n  }\n\n  _op(mask, op) {\n    let masks = Mask.commonalize(this.value, mask);\n    if (!masks[0]) {\n      return new Mask();\n    }\n    let a = masks[0].split('|')[1].split('');\n    let b = masks[1].split('|')[1].split('');\n    let result = [];\n    let length = a.length;\n    for (let i = 0; i < length; i++) {\n      result[i] = op(a[i], b[i]);\n    }\n    return new Mask(Mask.trim(masks[0].split('|')[0] + '|' + result.join('')), false);\n  };\n\n  /**\n   * @param {Array.<String>} dates\n   * @returns {Mask}\n   */\n  static fromDates(dates) {\n    if (!dates || !dates.length) {\n      return new Mask();\n    }\n    dates = dates.slice().sort();\n    let start = dates[0];\n    let mask = '1';\n    let length = dates.length;\n    for (let i = 1; i < length; i++) {\n      mask += repeat('0', durationToDays(getDate(dates[i]) - getDate(dates[i - 1])) - 1);\n      mask += '1';\n    }\n    return new Mask(start + '|' + mask);\n  }\n\n  /**\n   * Trims the mask. Any leading and trailing zeros are removed, and the start\n   * date is updated accordingly.\n   * @param {String} mask\n   * @returns {String}\n   */\n  static trim(mask) {\n    if (!mask || mask.indexOf('1') === -1) {\n      return '';\n    } else {\n      let parts = mask.split('|');\n      let start = parts[0];\n      let value = parts[1];\n      if (value.indexOf('1') === -1) {\n        return '';\n      } else if (value[0] === '1' && value[value.length - 1] === '1') {\n        return mask;\n      } else {\n        start = getString(plusDays(getDate(start), value.indexOf('1')));\n        value = value.substring(value.indexOf('1'), value.lastIndexOf('1') + 1);\n        return start + '|' + value;\n      }\n    }\n  }\n\n  /**\n   * Takes two masks and returns two new masks with the same start and end dates\n   * Note that these masks are potentially invalid since they are untrimmed. To\n   * trim them, use Mask.trim().\n   * @param {Mask|String} maskA\n   * @param {Mask|String} maskB\n   * @returns {Array.<String>}\n   */\n  static commonalize(maskA, maskB) {\n    maskA = maskA && maskA.toString();\n    maskB = maskB && maskB.toString();\n    let a = !!maskA && maskA.split('|');\n    let b = !!maskB && maskB.split('|');\n    if (!a && !b) {\n      return ['', ''];\n    }\n    if (!a) {\n      a = [b[0], repeat('0', b[1].length)];\n    } else if ( !b ) {\n      b = [a[0], repeat('0', a[1].length)];\n    }\n    let diff;\n    if (a[0] < b[0]) {\n      diff = durationToDays(getDate(b[0]) - getDate(a[0]));\n      a[1] += repeat('0', diff);\n      b[1] = repeat('0', diff) + b[1];\n      b[0] = a[0];\n    } else if (b[0] < a[0]) {\n      diff = durationToDays(getDate(a[0]) - getDate(b[0]));\n      b[1] += repeat('0', diff);\n      a[1] = repeat('0', diff) + a[1];\n      a[0] = b[0];\n    }\n    if (a[1].length < b[1].length) {\n      a[1] += repeat('0', b[1].length - a[1].length);\n    }\n    if (b[1].length < a[1].length) {\n      b[1] += repeat('0', a[1].length - b[1].length);\n    }\n    return [a.join('|'), b.join('|')];\n  }\n};\n",
    "import {\n  getDate,\n  getMonth,\n  getMonthsBetween,\n  getYear,\n} from './util';\n\nexport default class MonthEngine {\n  constructor({ start, end, interval, resolve }) {\n    this._interval = interval;\n    this._resolve = resolve;\n\n    let patternStart = getDate(start);\n    let year = getYear(patternStart);\n    let month = getMonth(patternStart);\n    let firstOccurrence = this._resolveDate(year, month);\n    if (firstOccurrence < patternStart) {\n      firstOccurrence = this._resolveDate(year, month + interval);\n    }\n    this.firstOccurrence = firstOccurrence;\n\n    if (end) {\n      this.lastOccurrence = this._getOccurrenceUntil(getDate(end));\n    } else {\n      this.lastOccurrence = null;\n    }\n  }\n\n  /**\n   * @param {Date} date\n   * @param {Number} direction\n   * @returns {Date}\n   */\n  snapToOccurrence(date, direction) {\n    let occurrence = this._getOccurrenceUntil(date);\n    if (occurrence < date && direction > 0) {\n      occurrence = this._resolveDate(getYear(occurrence), getMonth(occurrence) + this._interval);\n    } else if (occurrence > date && direction < 0) {\n      occurrence = this._resolveDate(getYear(occurrence), getMonth(occurrence) - this._interval);\n    }\n    if (occurrence < this.firstOccurrence) {\n      occurrence = this.firstOccurrence;\n    } else if (this.lastOccurrence && occurrence > this.lastOccurrence) {\n      occurrence = this.lastOccurrence;\n    }\n    return occurrence;\n  }\n\n  /**\n   * @param {Date} date\n   * @param {Number} direction\n   * @returns {Date}\n   */\n  next(occurrence, direction) {\n    return this._resolveDate(getYear(occurrence), getMonth(occurrence) + (this._interval * direction));\n  }\n\n  /**\n   * @param {Date} date\n   * @returns {Date}\n   */\n  _getOccurrenceUntil(date) {\n    if (date < this.firstOccurrence) {\n      return this.firstOccurrence;\n    }\n    let months = Math.floor(getMonthsBetween(this.firstOccurrence, date) / this._interval) * this._interval;\n    let occurrence = this._resolveDate(getYear(this.firstOccurrence), getMonth(this.firstOccurrence) + months);\n    if (occurrence > date) {\n      occurrence = this._resolveDate(getYear(occurrence), getMonth(occurrence) - this._interval);\n    }\n    if (occurrence < this.firstOccurrence) {\n      occurrence = this.firstOccurrence;\n    }\n    return occurrence;\n  }\n\n  /**\n   * @param {Number} year\n   * @param {Number} month\n   * @returns {Date}\n   */\n  _resolveDate(year, month) {\n    if (month > 12) {\n      year += Math.floor(month / 12);\n      month -= Math.floor(month / 12) * 12;\n    } else if (month < 1) {\n      year -= Math.ceil((month - 1) * -1 / 12);\n      month += Math.ceil((month - 1) * -1 / 12) * 12;\n    }\n    return this._resolve(year, month);\n  }\n};\n",
    "import {\n  dayOfWeekFromFlag,\n  getDayOfWeek,\n  getInstance,\n  getMonthsBetween,\n  resolveInstanceDate,\n} from './util';\n\nimport MonthEngine from './MonthEngine';\n\nexport default class MonthNthEngine {\n  constructor(pattern) {\n    this._dayOfWeek = dayOfWeekFromFlag(pattern.day_of_week_mask);\n    this._interval = pattern.interval;\n    this._instance = pattern.instance;\n    this._engine = new MonthEngine({\n      start: pattern.start_date,\n      end: pattern.end_date,\n      interval: this._interval,\n      resolve: (year, month) => resolveInstanceDate(year, month, this._instance, this._dayOfWeek)\n    });\n  }\n\n  snapToOccurrence(date, direction) {\n    return this._engine.snapToOccurrence(date, direction);\n  }\n\n  next(occurrence, direction) {\n    return this._engine.next(occurrence, direction);\n  }\n\n  matchesInterval(date) {\n    return (\n      getDayOfWeek(date) === this._dayOfWeek &&\n      getInstance(date) === this._instance &&\n      getMonthsBetween(date, this._engine.firstOccurrence) % this._interval === 0\n    );\n  }\n};\n",
    "import {\n  getMonth,\n  getMonthsBetween,\n  getYear,\n  resolveDate,\n} from './util';\n\nimport MonthEngine from './MonthEngine';\n\nexport default class MonthlyEngine {\n  constructor(pattern) {\n    this._interval = pattern.interval;\n    this._day = pattern.day_of_month;\n    this._engine = new MonthEngine({\n      start: pattern.start_date,\n      end: pattern.end_date,\n      interval: pattern.interval,\n      resolve: (year, month) => resolveDate(year, month, pattern.day_of_month)\n    });\n  }\n\n  /**\n   * @param {Date} date\n   * @param {Number} direction\n   * @returns {Date}\n   */\n  snapToOccurrence(date, direction) {\n    return this._engine.snapToOccurrence(date, direction);\n  }\n\n  /**\n   * @param {Date} date\n   * @param {Number} direction\n   * @returns {Date}\n   */\n  next(occurrence, direction) {\n    return this._engine.next(occurrence, direction);\n  }\n\n  /**\n   * Gets a value indicating whether the date falls on the pattern interval.\n   * @param {Date} date\n   * @returns {Date}\n   */\n  matchesInterval(date) {\n    return (\n      +resolveDate(getYear(date), getMonth(date), this._day) === +date &&\n      getMonthsBetween(this._engine.firstOccurrence, date) % this._interval === 0\n    );\n  }\n};\n",
    "import TYPE from './type';\n\nimport {\n  dayOfWeekFromFlag,\n  durationToDays,\n  find,\n  findIndex,\n  getDate,\n  getString,\n  normalizeDirection,\n  plusDays,\n  repeat,\n  validateDate\n} from './util';\n\nimport InvalidPatternError from './errors/InvalidPatternError';\nimport InvalidOperationError from './errors/InvalidOperationError';\n\nimport Mask from './Mask';\n\nimport DailyEngine from './DailyEngine';\nimport WeeklyEngine from './WeeklyEngine';\nimport MonthlyEngine from './MonthlyEngine';\nimport MonthNthEngine from './MonthNthEngine';\nimport YearlyEngine from './YearlyEngine';\nimport YearNthEngine from './YearNthEngine';\n\nexport default class Pattern {\n  /**\n   * @param {PatternJson} [pattern]\n   */\n  constructor(pattern) {\n    this.value = {\n      start_date: null,\n      end_date: null,\n      type: null,\n      day_of_week_mask: null,\n      day_of_month: null,\n      month_of_year: null,\n      interval: null,\n      instance: null,\n      exceptions: [],\n      ...pattern\n    };\n    this._validated = false;\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  validate() {\n    if (this._validated) {\n      return this;\n    }\n    this._validatePeriod();\n    this._validateType();\n    this._validateDayOfWeekMask();\n    this._validateInterval();\n    this._validateExceptions();\n    this._validated = true;\n    return this;\n  }\n\n  /**\n   * @param {Number} interval\n   * @returns {Pattern}\n   */\n  every(interval = 1) {\n    this._validated = false;\n    this.value.interval = interval;\n    return this;\n  }\n\n  /**\n   * @param {Number} [dayOfMonth]\n   * @returns {Pattern}\n   */\n  day(dayOfMonth) {\n    if (dayOfMonth === undefined) {\n      return this.days();\n    } else {\n      this._validated = false;\n      this.value.instance = null;\n      this.value.day_of_month = dayOfMonth;\n      return this;\n    }\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  days() {\n    this._validated = false;\n    this.value.type = TYPE.Daily;\n    this.value.day_of_week_mask = null;\n    this.value.instance = null;\n    return this;\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  week() {\n    this._validated = false;\n    this.value.type = TYPE.Weekly;\n    return this;\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  weeks() {\n    return this.week();\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  month() {\n    this._validated = false;\n    if (this.value.instance) {\n      this.value.type = TYPE.MonthNth;\n    } else {\n      this.value.type = TYPE.Monthly;\n      this.value.day_of_week_mask = null;\n    }\n    return this;\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  months() {\n    return this.month();\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  year() {\n    this._validated = false;\n    if (this.value.instance) {\n      this.value.type = TYPE.YearNth;\n    } else {\n      this.value.type = TYPE.Yearly;\n      this.value.day_of_week_mask = null;\n    }\n    return this;\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  years() {\n    return this.year();\n  }\n\n  /**\n   * @param {Number} dayOfWeekMask\n   * @returns {Pattern}\n   */\n  on(dayOfWeekMask) {\n    this._validated = false;\n    this.value.day_of_week_mask = dayOfWeekMask;\n    this.value.instance = null;\n    return this;\n  }\n\n  /**\n   * @param {Number} instance\n   * @param {Number} dayOfWeek\n   * @returns {Pattern}\n   */\n  the(instance, dayOfWeek) {\n    this._validated = false;\n    this.value.instance = instance;\n    this.value.day_of_week_mask = dayOfWeek;\n    return this;\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Pattern}\n   */\n  from(date) {\n    this._validated = false;\n    this.value.start_date = date;\n    return this;\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Pattern}\n   */\n  to(date) {\n    this._validated = false;\n    this.value.end_date = date;\n    return this;\n  }\n\n  /**\n   * @param {String} date\n   * @param {String} newDate\n   * @returns {Pattern}\n   */\n  addException(date, newDate) {\n    this._validated = false;\n    let exception = find(this.value.exceptions, function(exception) {\n      return exception.original_date === date;\n    });\n    if (!exception) {\n      exception = {};\n      this.value.exceptions.push(exception);\n    }\n    exception.original_date = date;\n    exception.date = newDate;\n    return this;\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Pattern}\n   */\n  removeException(date) {\n    this._validated = false;\n    let index = findIndex(this.value.exceptions, function(exception) {\n      return exception.original_date === date;\n    });\n    if (index > -1) {\n      this.value.exceptions.splice(index, 1);\n    }\n    return this;\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  removeAllExceptions() {\n    this._validated = false;\n    this.value.exceptions = [];\n    return this;\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Pattern}\n   */\n  findException(date) {\n    return find(this.value.exceptions, function(exception) {\n      return exception.original_date === date;\n    });\n  }\n\n  /**\n   * Determines whether the specified date occurs in the recurrence pattern.\n   * @param {String} date\n   * @returns {Boolean}\n   */\n  matches(date) {\n    this.validate();\n    if (this._exceptionsByDate[date]) {\n      return true;\n    }\n    if (this._moved[date]) {\n      return false;\n    }\n    if (!this._doesOccurWithinPeriod(date)) {\n      return false;\n    }\n    return this._engine.matchesInterval(getDate(date));\n  }\n\n  /**\n   * Gets the recurrence pattern as a plain old JSON object.\n   * @returns {PatternJson}\n   */\n  toJSON() {\n    return this.value;\n  }\n\n  /**\n   * @param {String} [end]\n   * @returns {Mask}\n   */\n  toMask(end) {\n    end = end || this.value.end_date;\n    if (!end) {\n      throw new InvalidOperationError('An end date is required to generate a mask.');\n    }\n    let mask = '';\n    let last, next;\n    while (next = this.next(last)) {\n      if (next > end) {\n        break;\n      }\n      let days = durationToDays(getDate(next) - getDate(last || this.value.start_date));\n      if (last) {\n        days -= 1;\n      }\n      mask += repeat('0', days);\n      mask += '1';\n      last = next;\n    }\n    if (mask) {\n      return new Mask(Mask.trim(this.value.start_date + '|' + mask));\n    } else {\n      return new Mask();\n    }\n  };\n\n  /**\n   * Gets the next occurrence or exception in the recurrence pattern after the\n   * specified date or returns false if there are no more occurrences.\n   * @param {String} [start] The date to search from.\n   * @param {Number} [direction]\n   *   A value indicating direction. Positive goes forward, negative goes backward.\n   * @returns {String|Boolean}\n   */\n  next(start, direction) {\n    this.validate();\n    if (typeof start !== \"string\") {\n      direction = start;\n      start = getString(plusDays(getDate(this.value.start_date), -1));\n    }\n    let date = start;\n    while (true) {\n      date = getString(this._getNextOccurrence(getDate(date), normalizeDirection(direction)));\n      if (this._doesOccurWithinPeriod(date)) {\n        // See if there's an exception for this date.\n        let exception = this._exceptionsByOriginalDate[date];\n        if (exception) {\n          if (exception.date) {\n            return date;\n          } else {\n            // This occurence was deleted. Get the next one.\n          }\n        } else {\n          return date;\n        }\n      } else {\n        // We're outside the range of the recurrence pattern.\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Gets the next date in the recurrence pattern after the specified date\n   * or returns false if there are no more occurrences.\n   * @param {String} start The date to search from.\n   * @param {Number} [direction]\n   *   A value indicating direction. Positive goes forward, negative goes backward.\n   * @returns {String|Boolean}\n   */\n  nextPatternDate(start, direction) {\n    this.validate();\n    let date = getString(this._getNextOccurrence(getDate(start), normalizeDirection(direction)));\n    if (this._doesOccurWithinPeriod(date)) {\n      return date;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Gets the next occurrence, or returns the specified date if it's valid.\n   * @param {String} date\n   * @param {Number} [direction]\n   *   A value indicating direction. Positive goes forward, negative goes backward.\n   * @returns {String|Boolean}\n   */\n  snap(date, direction) {\n    this.validate();\n    return getString(this._snapToOccurrence(getDate(date), normalizeDirection(direction)));\n  }\n\n  _validatePeriod() {\n    if (!this.value.start_date) {\n      throw new InvalidPatternError('A start date is required.');\n    }\n    this.value.start_date = String(this.value.start_date);\n    validateDate(this.value.start_date);\n    if (this.value.end_date) {\n      this.value.end_date = String(this.value.end_date);\n      validateDate(this.value.end_date);\n      if (this.value.start_date > this.value.end_date) {\n        throw new InvalidPatternError('The end date must be greater than or equal to the start date');\n      }\n    }\n  }\n\n  _validateType() {\n    if (!this.value.type) {\n      throw new InvalidPatternError('A recurrence type is required.');\n    }\n    this.value.type = Number(this.value.type);\n    switch (this.value.type) {\n      case TYPE.Daily:\n        this._engine = new DailyEngine(this.value);\n        break;\n      case TYPE.Weekly:\n        this._engine = new WeeklyEngine(this.value);\n        break;\n      case TYPE.Monthly:\n        this._engine = new MonthlyEngine(this.value);\n        break;\n      case TYPE.MonthNth:\n        this._engine = new MonthNthEngine(this.value);\n        break;\n      case TYPE.Yearly:\n        this._engine = new YearlyEngine(this.value);\n        break;\n      case TYPE.YearNth:\n        this._engine = new YearNthEngine(this.value);\n        break;\n      default:\n        throw new InvalidPatternError('The recurrence type \"' + this.value.type + '\" is invalid.');\n    }\n  }\n\n  _validateDayOfWeekMask() {\n    if (\n      this.value.type === TYPE.Weekly ||\n      this.value.type === TYPE.MonthNth ||\n      this.value.type === TYPE.YearNth\n    ) {\n      if (!this.value.day_of_week_mask) {\n        throw new InvalidPatternError('A day of week mask is required for Weekly, MonthNth, and YearNth recurrence patterns.');\n      }\n      if (this.value.type === TYPE.MonthNth || this.value.type === TYPE.YearNth) {\n        if (dayOfWeekFromFlag(this.value.day_of_week_mask) % 1 !== 0) {\n          throw new InvalidPatternError('Only one day of week may be specified for MonthNth and YearNth recurrence patterns.');\n        }\n      }\n    } else {\n      this.value.day_of_week_mask = null;\n    }\n  }\n\n  _validateInterval() {\n    if (!this.value.interval) {\n      throw new InvalidPatternError('A recurrence interval is required.');\n    }\n    this.value.interval = Number(this.value.interval);\n    if (isNaN(this.value.interval) || this.value.interval <= 0) {\n      throw new InvalidPatternError('The recurrence interval must be a number greater than 0.');\n    }\n  }\n\n  _validateExceptions() {\n    this._exceptionsByDate = {};\n    this._exceptionsByOriginalDate = {};\n    this._moved = {};\n    this.value.exceptions = this.value.exceptions || [];\n\n    this._validated = true;\n    let exceptions = {};\n    try {\n      this.value.exceptions.forEach(exception => {\n        if (!this.matches(exception.original_date)) {\n          throw new InvalidPatternError('An exception exists for an invalid date \"' + exception.original_date + '\".');\n        }\n        if (exceptions[exception.original_date]) {\n          throw new InvalidPatternError('More than one exception exists for \"' + exception.original_date + '\".');\n        }\n        if (exception.date) {\n          if (\n            exception.date < this.value.start_date ||\n            !!this.value.end_date && exception.date > this.value.end_date\n          ) {\n            throw new InvalidPatternError('The exception for \"' + exception.original_date + '\" is outside the pattern period.');\n          }\n          if (exception.date !== exception.original_date && this.matches(exception.date)) {\n            throw new InvalidPatternError('The exception for \"' + exception.original_date + '\" cannot occur on the same date as a regular occurrence.\"');\n          }\n          if (exceptions[exception.original_date]) {\n            throw new InvalidPatternError('More than one exception exists for \"' + exception.original_date + '\".');\n          }\n          if (exception.date <= this.nextPatternDate(exception.original_date, -1)) {\n            throw new InvalidPatternError('The exception for \"' + exception.original_date + '\" must occur after the previous occurrence.');\n          }\n          if (exception.date >= this.nextPatternDate(exception.original_date, 1)) {\n            throw new InvalidPatternError('The exception for \"' + exception.original_date + '\" must occur before the next occurrence.');\n          }\n        }\n        exceptions[exception.original_date] = true;\n      });\n    } finally {\n      this._validated = false;\n    }\n\n    this.value.exceptions.forEach(exception => {\n      this._exceptionsByOriginalDate[exception.original_date] = exception;\n      if (exception.original_date !== exception.date) {\n        this._moved[exception.original_date] = true;\n      }\n      if (exception.date) {\n        this._exceptionsByDate[exception.date] = exception;\n      }\n    });\n  }\n\n  /**\n   * @private\n   * @param {String} date\n   * @returns {Boolean}\n   */\n  _doesOccurWithinPeriod(date) {\n    return (\n      date >= this.value.start_date &&\n      (!this.value.end_date || date <= this.value.end_date)\n    );\n  }\n\n  /**\n   * Gets the next valid occurrence starting from the specified date. A negative\n   * direction gets the previous occurrence rather than the next.\n   * @private\n   * @param {Date} start The date to start from.\n   * @param {Number} direction Must be 1 or -1.\n   * @returns {Date}\n   */\n  _getNextOccurrence(start, direction) {\n    let occurrence = this._snapToOccurrence(start, direction);\n    if (+occurrence !== +start) {\n      return occurrence;\n    }\n    return this._engine.next(occurrence, direction);\n  }\n\n  /**\n   * Gets the nearest valid occurrence to the specified date. If occurrences\n   * exist before and after the date, a positive direction returns the later\n   * occurrence whereas a negative direction returns the earlier occurrence.\n   * @private\n   * @param {Date} date The date to snap to.\n   * @param {Number} direction Must be 1 or -1.\n   * @returns {Date}\n   */\n  _snapToOccurrence(date, direction) {\n    return this._engine.snapToOccurrence(date, direction);\n  }\n};\n\n[\n  'January', 'February', 'March', 'April', 'May', 'June', 'July',\n  'August', 'September', 'October', 'November', 'December'\n].forEach(function(month, index) {\n  Pattern.prototype[month.toLowerCase()] = function(dayOfMonth) {\n    this._validated = false;\n    this.value.month_of_year = index + 1;\n    if (dayOfMonth) {\n      this.value.day_of_month = dayOfMonth;\n      this.value.instance = null;\n    }\n    return this;\n  };\n\n  Pattern.prototype['of' + month] = function(dayOfMonth) {\n    this._validated = false;\n    this.value.month_of_year = index + 1;\n    if (dayOfMonth) {\n      this.value.day_of_month = dayOfMonth;\n      this.value.instance = null;\n    }\n    return this;\n  };\n});\n",
    "import DAYS from './days';\nimport {\n  dayOfWeekMaskToArray,\n  durationToWeeks,\n  getDate,\n  getDayOfWeekFlag,\n  getSunday,\n  hasFlag,\n  plusDays,\n  plusWeeks,\n} from './util';\n\nexport default class WeeklyEngine {\n  constructor(pattern) {\n    this._interval = pattern.interval;\n    this._dayOfWeekMask = pattern.day_of_week_mask;\n    this._startDate = pattern.start_date;\n    this._endDate = pattern.end_date;\n  }\n\n  /**\n   * @param {Date} date\n   * @param {Number} direction\n   * @returns {Date}\n   */\n  snapToOccurrence(date, direction) {\n    while (!this._doesMatchDayOfWeek(date)) {\n      date = plusDays(date, direction);\n    }\n\n    let firstDay = getDate(this._startDate);\n    while (!this._doesMatchDayOfWeek(firstDay)) {\n      firstDay = plusDays(firstDay, 1);\n    }\n    if (date <= firstDay) {\n      return firstDay;\n    }\n\n    if (this._endDate) {\n      let lastDay = getDate(this._endDate);\n      while (!this._doesMatchDayOfWeek(lastDay)) {\n        lastDay = plusDays(lastDay, -1);\n      }\n      if (date >= lastDay) {\n        return lastDay;\n      }\n    }\n\n    let remainder = durationToWeeks(getSunday(date) - getSunday(firstDay)) % this._interval;\n    if (remainder > 0) {\n      date = plusWeeks(date, remainder * direction);\n      let maskDays = dayOfWeekMaskToArray(this._dayOfWeekMask);\n      if (direction > 0) {\n        // Starting from Sunday, get the first valid date going forward from\n        // Sunday to Saturday.\n        return plusDays(getSunday(date), maskDays[0]);\n      } else {\n        // Starting from next Sunday, get the first valid date going backward\n        // from Saturday to Sunday.\n        return plusDays(getSunday(plusWeeks(date, 1)), -(7 - maskDays[maskDays.length - 1]));\n      }\n    } else {\n      return date;\n    }\n  }\n\n  /**\n   * @param {Date} occurrence\n   * @param {Number} direction\n   * @returns {Date}\n   */\n  next(occurrence, direction) {\n    do {\n      occurrence = plusDays(occurrence, direction);\n      // If it's Sunday, jump to the next valid week. If the interval is 1,\n      // then we're already there.\n      if (getDayOfWeekFlag(occurrence) === DAYS.Sunday) {\n        occurrence = plusWeeks(occurrence, (this._interval - 1) * direction);\n      }\n    } while (!this._doesMatchDayOfWeek(occurrence));\n    return occurrence;\n  }\n\n  /**\n   * Gets a value indicating whether the date falls on the pattern interval.\n   * @param {Date} date\n   * @returns {Boolean}\n   */\n  matchesInterval(date) {\n    return (\n      this._doesMatchDayOfWeek(date) &&\n      this._doesMatchWeeklyInterval(date)\n    );\n  }\n\n  /**\n   * @private\n   * @param {Date} date\n   * @returns {Boolean}\n   */\n  _doesMatchDayOfWeek(date) {\n    return hasFlag(this._dayOfWeekMask, getDayOfWeekFlag(date));\n  }\n\n  /**\n   * @private\n   * @param {Date} date\n   * @returns {Boolean}\n   */\n  _doesMatchWeeklyInterval(date) {\n    let start = getSunday(getDate(this._startDate));\n    let end = getSunday(date);\n    let weeks = durationToWeeks(end - start);\n    return weeks % this._interval === 0;\n  }\n};\n",
    "import {\n  dayOfWeekFromFlag,\n  getDayOfWeek,\n  getInstance,\n  getMonth,\n  getYearsBetween,\n  resolveInstanceDate,\n} from './util';\n\nimport MonthEngine from './MonthEngine';\n\nexport default class YearNthEngine {\n  constructor(pattern) {\n    this._dayOfWeek = dayOfWeekFromFlag(pattern.day_of_week_mask);\n    this._instance = pattern.instance;\n    this._interval = pattern.interval;\n    this._month = pattern.month_of_year;\n    this._engine = new MonthEngine({\n      start: pattern.start_date,\n      end: pattern.end_date,\n      interval: pattern.interval * 12,\n      resolve: year => resolveInstanceDate(year, pattern.month_of_year, pattern.instance, this._dayOfWeek)\n    });\n  }\n\n  snapToOccurrence(date, direction) {\n    return this._engine.snapToOccurrence(date, direction);\n  }\n\n  next(occurrence, direction) {\n    return this._engine.next(occurrence, direction);\n  }\n\n  matchesInterval(date) {\n    return (\n      getDayOfWeek(date) === this._dayOfWeek &&\n      getInstance(date) === this._instance &&\n      getMonth(date) === this._month &&\n      getYearsBetween(date, this._engine.firstOccurrence) % this._interval === 0\n    );\n  }\n};\n",
    "import {\n  getMonth,\n  getYear,\n  getYearsBetween,\n  resolveDate,\n} from './util';\n\nimport MonthEngine from './MonthEngine';\n\nexport default class YearlyEngine {\n  constructor(pattern) {\n    this._day = pattern.day_of_month;\n    this._month = pattern.month_of_year;\n    this._interval = pattern.interval;\n    this._engine = new MonthEngine({\n      start: pattern.start_date,\n      end: pattern.end_date,\n      interval: pattern.interval * 12,\n      resolve: year => resolveDate(year, pattern.month_of_year, pattern.day_of_month)\n    });\n  }\n\n  snapToOccurrence(date, direction) {\n    return this._engine.snapToOccurrence(date, direction);\n  }\n\n  next(occurrence, direction) {\n    return this._engine.next(occurrence, direction);\n  }\n\n  matchesInterval(date) {\n    return (\n      +resolveDate(getYear(date), getMonth(date), this._day) === +date &&\n      getMonth(date) === this._month &&\n      getYearsBetween(this._engine.firstOccurrence, date) % this._interval === 0\n    );\n  }\n};\n",
    "/**\n * @enum {Number}\n * Days of the week.\n */\nexport default {\n  Sunday: 1,\n  Monday: 2,\n  Tuesday: 4,\n  Wednesday: 8,\n  Thursday: 16,\n  Friday: 32,\n  Saturday: 64,\n  All: 1 | 2 | 4 | 8 | 16 | 32 | 64,\n  Weekdays: 2 | 4 | 8 | 16 | 32,\n  Weekends: 1 | 64\n};\n",
    "export default class InvalidDateError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'InvalidDateError';\n    this.message = message;\n  }\n};\n",
    "export default class InvalidMaskError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'InvalidMaskError';\n    this.message = message;\n  }\n};\n",
    "export default class InvalidOperationError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'InvalidOperationError';\n    this.message = message;\n  }\n};\n",
    "export default class InvalidPatternError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'InvalidPatternError';\n    this.message = message;\n  }\n};\n",
    "import Pattern from './Pattern';\nimport Mask from './Mask';\nimport days from './days';\nimport type from './type';\n\nimport InvalidDateError from './errors/InvalidDateError';\nimport InvalidMaskError from './errors/InvalidMaskError';\nimport InvalidOperationError from './errors/InvalidOperationError';\nimport InvalidPatternError from './errors/InvalidPatternError';\n\nvar exports = function() {\n  return new Pattern();\n};\n\nexports.Pattern = Pattern;\nexports.Mask = Mask;\nexports.days = days;\nexports.type = type;\n\nexports.errors = {\n  InvalidDateError,\n  InvalidMaskError,\n  InvalidOperationError,\n  InvalidPatternError,\n};\n\nexport default exports;\n",
    "/**\n * @enum {Number}\n * Recurrence types.\n */\nexport default {\n  Daily: 1,\n  Weekly: 2,\n  Monthly: 3,\n  MonthNth: 4,\n  Yearly: 5,\n  YearNth: 6\n};\n",
    "import InvalidDateError from './errors/InvalidDateError';\n\nconst DATE_PATTERN = /[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}/;\n\n/**\n * @param {String} date\n * @returns {Date}\n */\nexport function getDate(date) {\n  if (!DATE_PATTERN.test(date)) {\n    throw new InvalidDateError('Date \"' + date + '\" is invalid. Expected format to be YYYY-MM-DD.');\n  }\n  let result = new Date(date + 'T00:00:00.000Z');\n  if (isNaN(result.getTime())) {\n    throw new InvalidDateError('Date \"' + date + '\" is invalid.');\n  }\n  return result;\n};\n\n/**\n * Creates a date object from the specified year/month/day.\n * @param {Number} year\n * @param {Number} month\n * @param {Number} day\n * @returns {Date}\n */\nexport function getDateFromParts(year, month, day) {\n  return getDate(`${year}-${padZero(month)}-${padZero(day)}`);\n};\n\n/**\n * Creates a date object from the specified year/month/day. If day is too high,\n * the last day of the month is used.\n * @param {Number} year\n * @param {Number} month [1-12]\n * @param {Number} day [1-31]\n * @returns {Date}\n */\nexport function resolveDate(year, month, day) {\n  let daysInMonth = getDaysInMonth(getDateFromParts(year, month, 1));\n  return getDateFromParts(year, month, Math.min(day, daysInMonth));\n};\n\nexport function getInstance(date) {\n  return Math.ceil(getDayOfMonth(date) / 7);\n};\n\n/**\n * @param {Number} year\n * @param {Number} month\n * @param {Number} instance [1-5]\n * @param {Number} dayOfWeek [0-6]\n * @returns {Date}\n */\nexport function resolveInstanceDate(year, month, instance, dayOfWeek) {\n  let day0 = getDateFromParts(year, month, 1);\n  let dow0 = getDayOfWeek(day0);\n  if (dayOfWeek < dow0) {\n    dayOfWeek += 7;\n  }\n  let firstInstance = 1 + dayOfWeek - dow0;\n  let day = firstInstance + (instance - 1) * 7;\n  let daysInMonth = getDaysInMonth(day0);\n  if (day > daysInMonth) {\n    day -= 7;\n  }\n  return getDateFromParts(year, month, day);\n};\n\n/**\n * @param {String} date\n */\nexport function validateDate(date) {\n  getDate(date);\n};\n\n/**\n * @param {Date} date\n * @returns {String}\n */\nexport function getString(date) {\n  let month = padZero(getMonth(date));\n  let day = padZero(getDayOfMonth(date));\n  return date.getUTCFullYear() + '-' + month + '-' + day;\n};\n\nexport function padZero(value) {\n  value = value.toString();\n  if (value.length === 1) {\n    value = '0' + value;\n  }\n  return value;\n};\n\nexport function getMonth(date) {\n  return date.getUTCMonth() + 1;\n};\n\nexport function getDayOfMonth(date) {\n  return date.getUTCDate();\n};\n\nexport function getYear(date) {\n  return date.getUTCFullYear();\n};\n\nexport function getDaysInMonth(date) {\n  let year = getYear(date);\n  let month = getMonth(date) + 1;\n  if (month > 12) {\n    month = 1;\n    year += 1;\n  }\n  date = getDate(`${year}-${padZero(month)}-01`);\n  date = plusDays(date, -1);\n  return getDayOfMonth(date);\n};\n\nexport function getFirstDayOfMonth(date) {\n  let [year, month, day] = getString(date).split('-');\n  return getDate(`${year}-${month}-01`);\n};\n\n/**\n * 0-6 Sunday-Saturday.\n * @param {Date} date\n * @returns {Number}\n */\nexport function getDayOfWeek(date) {\n  return date.getUTCDay();\n};\n\n/**\n * @param {Date} date\n * @returns {Number}\n */\nexport function getDayOfWeekFlag(date) {\n  return dayOfWeekToFlag(getDayOfWeek(date));\n};\n\n/**\n * @param {Number} day\n * @returns {Number}\n */\nexport function dayOfWeekToFlag(day) {\n  return Math.pow(2, day);\n};\n\n/**\n * @param {Number} flag\n * @returns {Number}\n */\nexport function dayOfWeekFromFlag(flag) {\n  return Math.log(flag) / Math.log(2);\n};\n\n/**\n * @param {Date} date\n * @returns {Date}\n */\nexport function getSunday(date) {\n  return plusDays(date, -getDayOfWeek(date));\n};\n\n/**\n * Determines whether a given bit mask contains the specified bit flag.\n * @param {Number} mask\n * @param {Number} flag\n * @returns {Boolean}\n */\nexport function hasFlag(mask, flag) {\n  return (mask & flag) === flag;\n};\n\n/**\n * Converts a JavaScript date value to days.\n * @param {Number} value\n *   The number of milliseconds since midnight of Jan 1, 1970 UTC.\n * @returns {Number}\n */\nexport function durationToDays(duration) {\n  return (+duration) / 1000 / 60 / 60 / 24;\n};\n\n/**\n * @param {Number} duration\n * @returns {Number}\n */\nexport function durationToWeeks(duration) {\n  return durationToDays(duration) / 7;\n};\n\nexport function getMonthsBetween(start, end) {\n  if (start > end) {\n    let temp = end;\n    end = start;\n    start = temp;\n  }\n  let startYear = getYear(start);\n  let startMonth = getMonth(start);\n  let endYear = getYear(end);\n  let endMonth = getMonth(end);\n  let years = endYear - startYear;\n  let months = 0;\n  if (endMonth > startMonth) {\n    months = endMonth - startMonth;\n  } else if (endMonth < startMonth) {\n    months = startMonth - endMonth;\n    years -= 1;\n  }\n  months += years * 12;\n  return months;\n};\n\nexport function getYearsBetween(start, end) {\n  return Math.abs(getYear(end) - getYear(start));\n};\n\n/**\n * @param {Number} days\n * @returns {Number}\n */\nexport function daysToDuration(days) {\n  return days * 24 * 60 * 60 * 1000;\n};\n\n/**\n * @param {Date} date\n * @param {Number} days\n * @returns {Date}\n */\nexport function plusDays(date, days) {\n  return new Date(+date + daysToDuration(days));\n};\n\n/**\n * @param {Date} date\n * @param {Number} weeks\n * @returns {Date}\n */\nexport function plusWeeks(date, weeks) {\n  return plusDays(date, weeks * 7);\n};\n\n/**\n * @param {Number} mask\n * @returns {Array.<Number>}\n */\nexport function dayOfWeekMaskToArray(mask) {\n  let days = [0, 1, 2, 3, 4, 5, 6];\n  let result = [];\n  days.forEach(function(day) {\n    if (hasFlag(mask, dayOfWeekToFlag(day))) {\n      result.push(day);\n    }\n  });\n  return result;\n};\n\nexport function normalizeDirection(direction) {\n  return direction < 0 ? -1 : 1;\n};\n\nexport function find(array, callback) {\n  let index = findIndex(array, callback);\n  if (index > -1) {\n    return array[index];\n  } else {\n    return null;\n  }\n};\n\nexport function findIndex(array, callback) {\n  for (let i = 0; i < array.length; i++) {\n    if (callback(array[i])) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nexport function repeat(string, times) {\n  let ret = '';\n  for (let i = 0; i < times; i++) {\n    ret += string;\n  }\n  return ret;\n};\n"
  ]
}