{
  "version": 3,
  "sources": [
    "../arceus/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "/Users/stephen/code/stephenbunch/dialga/src/Mask.js",
    "/Users/stephen/code/stephenbunch/dialga/src/Pattern.js",
    "/Users/stephen/code/stephenbunch/dialga/src/days.js",
    "/Users/stephen/code/stephenbunch/dialga/src/errors/InvalidDateError.js",
    "/Users/stephen/code/stephenbunch/dialga/src/errors/InvalidMaskError.js",
    "/Users/stephen/code/stephenbunch/dialga/src/errors/InvalidOperationError.js",
    "/Users/stephen/code/stephenbunch/dialga/src/errors/InvalidPatternError.js",
    "/Users/stephen/code/stephenbunch/dialga/src/errors/NotSupportedError.js",
    "/Users/stephen/code/stephenbunch/dialga/src/index.js",
    "/Users/stephen/code/stephenbunch/dialga/src/type.js",
    "/Users/stephen/code/stephenbunch/dialga/src/util.js"
  ],
  "names": [],
  "mappings": "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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "import InvalidMaskError from './errors/InvalidMaskError';\nimport {\n  durationToDays,\n  getDate,\n  getString,\n  plusDays,\n  repeat,\n  validateDate\n} from './util';\n\nexport default class Mask {\n  /**\n   * A mask contains a start date and a series of 1s and 0s where a 1 represents\n   * an occurrence. A mask always starts and ends with a 1. It may also contain a\n   * single 1 if there is only one occurrence.\n   * @param {String} mask\n   */\n  constructor(mask) {\n    this.value = mask || '';\n    this.start_date = null;\n\n    if (this.value) {\n      var parts = this.value.split('|');\n      if (parts.length !== 2) {\n        throw new InvalidMaskError('Mask is invalid. Expected format [yyyy-mm-dd]|[mask] but found \"' + this.value + '\".');\n      }\n      validateDate(parts[0]);\n      this.start_date = parts[0];\n      if (parts[1][0] !== '1') {\n        throw new InvalidMaskError('Mask format is invalid. Mask value should begin with a \"1\".');\n      }\n      if (parts[1][parts[1].length - 1] !== '1') {\n        throw new InvalidMaskError('Mask format is invalid. Mask value should end with a \"1\".');\n      }\n    }\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  /**\n   * @param {Mask|String} mask\n   * @returns {Mask}\n   */\n  or(mask) {\n    return this._op(mask, (a, b) => {\n      return Boolean(Number(a)) | Boolean(Number(b));\n    });\n  }\n\n  /**\n   * @param {Mask|String} mask\n   * @returns {Mask}\n   */\n  and(mask) {\n    return this._op(mask, (a, b) => {\n      return Boolean(Number(a)) & Boolean(Number(b));\n    });\n  }\n\n  /**\n   * @param {Mask|String} mask\n   * @returns {Mask}\n   */\n  xor(mask) {\n    return this._op(mask, (a, b) => {\n      return Boolean(Number(a)) ^ Boolean(Number(b));\n    });\n  }\n\n  /**\n   * @param {Mask|String} mask\n   * @returns {Mask}\n   */\n  not(mask) {\n    return this._op(mask, (a, b) => {\n      if (Boolean(Number(b))) {\n        return 0;\n      } else {\n        return Number(Boolean(Number(a)));\n      }\n    });\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Boolean}\n   */\n  matches(date) {\n    if (!this.value) {\n      return false;\n    }\n    var values = this.value.split('|');\n    var start = values[0];\n    if (date < start) {\n      return false;\n    }\n    var index = durationToDays(getDate(date) - getDate(start));\n    return values[1][index] === '1';\n  }\n\n  /**\n   * @returns {Array.<String>}\n   */\n  getDates() {\n    if (!this.value) {\n      return [];\n    }\n    var dates = [];\n    var values = this.value.split('|');\n    var start = values[0];\n    dates.push(start);\n    start = getDate(start);\n    var days = values[1].split('');\n    var length = days.length;\n    for (var i = 1; i < length; i++) {\n      if (days[i] === '1') {\n        dates.push(getString(plusDays(start, i)));\n      }\n    }\n    return dates;\n  }\n\n  /**\n   * @returns {Array.<String>|null}\n   */\n  getRange() {\n    if (!this.value) {\n      return null;\n    }\n    var values = this.value.split('|');\n    var start = getDate(values[0]);\n    var end = plusDays(start, values[1].length - 1);\n    return [getString(start), getString(end)];\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Mask}\n   */\n  addDate(date) {\n    return this.or(date + '|1');\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Mask}\n   */\n  removeDate(date) {\n    return this.not(date + '|1');\n  }\n\n  /**\n   * @param {String} date\n   * @param {Boolean} [state]\n   * @returns {Mask}\n   */\n  toggleDate(date, state) {\n    if (state === undefined) {\n      if (this.matches(date)) {\n        return this.removeDate(date);\n      } else {\n        return this.addDate(date);\n      }\n    } else {\n      if (state) {\n        return this.addDate(date);\n      } else {\n        return this.removeDate(date);\n      }\n    }\n  }\n\n  _op(mask, op) {\n    var masks = Mask.commonalize(this.value, mask);\n    if (!masks[0]) {\n      return new Mask();\n    }\n    var a = masks[0].split('|')[1].split('');\n    var b = masks[1].split('|')[1].split('');\n    var result = [];\n    var length = a.length;\n    for (var i = 0; i < length; i++) {\n      result[i] = op(a[i], b[i]);\n    }\n    return new Mask(Mask.trim(masks[0].split('|')[0] + '|' + result.join('')), false);\n  };\n\n  /**\n   * @param {Array.<String>} dates\n   * @returns {Mask}\n   */\n  static fromDates(dates) {\n    if (!dates || !dates.length) {\n      return new Mask();\n    }\n    dates = dates.slice().sort();\n    var start = dates[0];\n    var mask = '1';\n    var length = dates.length;\n    for (var i = 1; i < length; i++) {\n      mask += repeat('0', durationToDays(getDate(dates[i]) - getDate(dates[i - 1])) - 1);\n      mask += '1';\n    }\n    return new Mask(start + '|' + mask);\n  }\n\n  /**\n   * Trims the mask. Any leading and trailing zeros are removed, and the start\n   * date is updated accordingly.\n   * @param {String} mask\n   * @returns {String}\n   */\n  static trim(mask) {\n    if (!mask || mask.indexOf('1') === -1) {\n      return '';\n    } else {\n      var parts = mask.split('|');\n      var start = parts[0];\n      var value = parts[1];\n      if (value.indexOf('1') === -1) {\n        return '';\n      } else if (value[0] === '1' && value[value.length - 1] === '1') {\n        return mask;\n      } else {\n        start = getString(plusDays(getDate(start), value.indexOf('1')));\n        value = value.substring(value.indexOf('1'), value.lastIndexOf('1') + 1);\n        return start + '|' + value;\n      }\n    }\n  }\n\n  /**\n   * Takes two masks and returns two new masks with the same start and end dates\n   * Note that these masks are potentially invalid since they are untrimmed. To\n   * trim them, use Mask.trim().\n   * @param {Mask|String} maskA\n   * @param {Mask|String} maskB\n   * @returns {Array.<String>}\n   */\n  static commonalize(maskA, maskB) {\n    maskA = maskA && maskA.toString();\n    maskB = maskB && maskB.toString();\n    var a = !!maskA && maskA.split('|');\n    var b = !!maskB && maskB.split('|');\n    if (!a && !b) {\n      return ['', ''];\n    }\n    if (!a) {\n      a = [b[0], repeat('0', b[1].length)];\n    } else if ( !b ) {\n      b = [a[0], repeat('0', a[1].length)];\n    }\n    var diff;\n    if (a[0] < b[0]) {\n      diff = durationToDays(getDate(b[0]) - getDate(a[0]));\n      a[1] += repeat('0', diff);\n      b[1] = repeat('0', diff) + b[1];\n      b[0] = a[0];\n    } else if (b[0] < a[0]) {\n      diff = durationToDays(getDate(a[0]) - getDate(b[0]));\n      b[1] += repeat('0', diff);\n      a[1] = repeat('0', diff) + a[1];\n      a[0] = b[0];\n    }\n    if (a[1].length < b[1].length) {\n      a[1] += repeat('0', b[1].length - a[1].length);\n    }\n    if (b[1].length < a[1].length) {\n      b[1] += repeat('0', a[1].length - b[1].length);\n    }\n    return [a.join('|'), b.join('|')];\n  }\n};\n",
    "import DAYS from './days';\nimport TYPE from './type';\nimport {\n  dayOfWeekMaskToArray,\n  durationToDays,\n  durationToWeeks,\n  extend,\n  find,\n  findIndex,\n  getDate,\n  getDayOfWeekFlag,\n  getString,\n  getSunday,\n  hasFlag,\n  normalizeDirection,\n  plusDays,\n  plusWeeks,\n  repeat,\n  validateDate\n} from './util';\nimport InvalidPatternError from './errors/InvalidPatternError';\nimport InvalidOperationError from './errors/InvalidOperationError';\nimport NotSupportedError from './errors/NotSupportedError';\nimport Mask from './Mask';\n\nexport default class Pattern {\n  /**\n   * @param {PatternJson} [pattern]\n   */\n  constructor(pattern) {\n    this.value = extend({\n      start_date: null,\n      end_date: null,\n      type: null,\n      day_of_week_mask: null,\n      day_of_month: null,\n      month_of_year: null,\n      interval: null,\n      instance: null,\n      exceptions: []\n    }, pattern );\n    this._validated = false;\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  validate() {\n    if (this._validated) {\n      return this;\n    }\n    this._validatePeriod();\n    this._validateType();\n    this._validateDayOfWeekMask();\n    this._validateInterval();\n    this._validateExceptions();\n    this._validated = true;\n    return this;\n  }\n\n  /**\n   * @param {Number} interval\n   * @returns {Pattern}\n   */\n  every(interval) {\n    this._validated = false;\n    this.value.interval = interval || 1;\n    return this;\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  day() {\n    this._validated = false;\n    this.value.type = TYPE.Daily;\n    this.value.day_of_week_mask = null;\n    this.value.instance = null;\n    return this;\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  days() {\n    return this.day();\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  week() {\n    this._validated = false;\n    this.value.type = TYPE.Weekly;\n    return this;\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  weeks() {\n    return this.week();\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  month() {\n    this._validated = false;\n    if (this.value.instance) {\n      this.value.type = TYPE.MonthNth;\n    } else {\n      this.value.type = TYPE.Monthly;\n      this.value.day_of_week_mask = null;\n    }\n    return this;\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  months() {\n    return this.month();\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  year() {\n    this._validated = false;\n    if (this.value.instance) {\n      this.value.type = TYPE.YearNth;\n    } else {\n      this.value.type = TYPE.Yearly;\n      this.value.day_of_week_mask = null;\n    }\n    return this;\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  years() {\n    return this.year();\n  }\n\n  /**\n   * @param {Number} dayOfWeekMask\n   * @returns {Pattern}\n   */\n  on(dayOfWeekMask) {\n    this._validated = false;\n    this.value.day_of_week_mask = dayOfWeekMask;\n    this.value.instance = null;\n    return this;\n  }\n\n  /**\n   * @param {Number} instance\n   * @param {Number} dayOfWeek\n   * @returns {Pattern}\n   */\n  the(instance, dayOfWeek) {\n    this._validated = false;\n    this.value.instance = instance;\n    this.value.day_of_week_mask = dayOfWeek;\n    return this;\n  }\n\n  /**\n   * @param {Number} dayOfMonth\n   * @returns {Pattern}\n   */\n  dayOfMonth(dayOfMonth) {\n    this._validated = false;\n    this.value.instance = null;\n    this.value.day_of_month = dayOfMonth;\n    return this;\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Pattern}\n   */\n  from(date) {\n    this._validated = false;\n    this.value.start_date = date;\n    return this;\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Pattern}\n   */\n  to(date) {\n    this._validated = false;\n    this.value.end_date = date;\n    return this;\n  }\n\n  /**\n   * @param {String} date\n   * @param {String} newDate\n   * @returns {Pattern}\n   */\n  addException(date, newDate) {\n    this._validated = false;\n    var exception = find(this.value.exceptions, function(exception) {\n      return exception.original_date === date;\n    });\n    if (!exception) {\n      exception = {};\n      this.value.exceptions.push(exception);\n    }\n    exception.original_date = date;\n    exception.date = newDate;\n    return this;\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Pattern}\n   */\n  removeException(date) {\n    this._validated = false;\n    var index = findIndex(this.value.exceptions, function(exception) {\n      return exception.original_date === date;\n    });\n    if (index > -1) {\n      this.value.exceptions.splice(index, 1);\n    }\n    return this;\n  }\n\n  /**\n   * @returns {Pattern}\n   */\n  removeAllExceptions() {\n    this._validated = false;\n    this.value.exceptions = [];\n    return this;\n  }\n\n  /**\n   * @param {String} date\n   * @returns {Pattern}\n   */\n  findException(date) {\n    return find(this.value.exceptions, function(exception) {\n      return exception.original_date === date;\n    });\n  }\n\n  /**\n   * Determines whether the specified date occurs in the recurrence pattern.\n   * @param {String} date\n   * @returns {Boolean}\n   */\n  matches(date) {\n    this.validate();\n    if (this._exceptionsByDate[date]) {\n      return true;\n    }\n    if (this._moved[date]) {\n      return false;\n    }\n    if (!this._doesOccurWithinPeriod(date)) {\n      return false;\n    }\n    switch (this.value.type) {\n      case TYPE.Daily:\n        return this._doesMatchDailyInterval(getDate(date));\n      case TYPE.Weekly:\n        return (\n          this._doesMatchDayOfWeek(getDate(date)) &&\n          this._doesMatchWeeklyInterval(getDate(date))\n        );\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Gets the recurrence pattern as a plain old JSON object.\n   * @returns {PatternJson}\n   */\n  toJSON() {\n    return this.value;\n  }\n\n  /**\n   * @param {String} [end]\n   * @returns {Mask}\n   */\n  toMask(end) {\n    end = end || this.value.end_date;\n    if (!end) {\n      throw new InvalidOperationError('An end date is required to generate a mask.');\n    }\n    var mask = '';\n    var last, next;\n    while (next = this.next(last)) {\n      if (next > end) {\n        break;\n      }\n      var days = durationToDays(getDate(next) - getDate(last || this.value.start_date));\n      if (last) {\n        days -= 1;\n      }\n      mask += repeat('0', days);\n      mask += '1';\n      last = next;\n    }\n    if (mask) {\n      return new Mask(Mask.trim(this.value.start_date + '|' + mask));\n    } else {\n      return new Mask();\n    }\n  };\n\n  /**\n   * Gets the next occurrence or exception in the recurrence pattern after the\n   * specified date or returns false if there are no more occurrences.\n   * @param {String} [start] The date to search from.\n   * @param {Number} [direction]\n   *   A value indicating direction. Positive goes forward, negative goes backward.\n   * @returns {String|Boolean}\n   */\n  next(start, direction) {\n    this.validate();\n    if (typeof start !== \"string\") {\n      direction = start;\n      start = getString(plusDays(getDate(this.value.start_date), -1));\n    }\n    var date = start;\n    while (true) {\n      date = getString(this._getNextOccurrence(getDate(date), normalizeDirection(direction)));\n      if (this._doesOccurWithinPeriod(date)) {\n        // See if there's an exception for this date.\n        var exception = this._exceptionsByOriginalDate[date];\n        if (exception) {\n          if (exception.date) {\n            return date;\n          } else {\n            // This occurence was deleted. Get the next one.\n          }\n        } else {\n          return date;\n        }\n      } else {\n        // We're outside the range of the recurrence pattern.\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Gets the next date in the recurrence pattern after the specified date\n   * or returns false if there are no more occurrences.\n   * @param {String} start The date to search from.\n   * @param {Number} [direction]\n   *   A value indicating direction. Positive goes forward, negative goes backward.\n   * @returns {String|Boolean}\n   */\n  nextPatternDate(start, direction) {\n    this.validate();\n    var date = getString(this._getNextOccurrence(getDate(start), normalizeDirection(direction)));\n    if (this._doesOccurWithinPeriod(date)) {\n      return date;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Gets the next occurrence, or returns the specified date if it's valid.\n   * @param {String} date\n   * @param {Number} [direction]\n   *   A value indicating direction. Positive goes forward, negative goes backward.\n   * @returns {String|Boolean}\n   */\n  snap(date, direction) {\n    this.validate();\n    return getString(this._snapToOccurrence(getDate(date), normalizeDirection(direction)));\n  }\n\n  _validatePeriod() {\n    if (!this.value.start_date) {\n      throw new InvalidPatternError('A start date is required.');\n    }\n    this.value.start_date = String(this.value.start_date);\n    validateDate(this.value.start_date);\n    if (this.value.end_date) {\n      this.value.end_date = String(this.value.end_date);\n      validateDate(this.value.end_date);\n      if (this.value.start_date > this.value.end_date) {\n        throw new InvalidPatternError('The end date must be greater than or equal to the start date');\n      }\n    }\n  }\n\n  _validateType() {\n    if (!this.value.type) {\n      throw new InvalidPatternError('A recurrence type is required.');\n    }\n    this.value.type = Number(this.value.type);\n    switch (this.value.type) {\n      case TYPE.Daily:\n      case TYPE.Weekly:\n        break;\n\n      case TYPE.Monthly:\n      case TYPE.MonthNth:\n      case TYPE.Yearly:\n      case TYPE.YearNth:\n        throw new NotSupportedError('\"Daily\" and \"Weekly\" are the only recurrence types supported at this time.');\n\n      default:\n        throw new InvalidPatternError('The recurrence type \"' + this.value.type + '\" is invalid.');\n    }\n  }\n\n  _validateDayOfWeekMask() {\n    if (this.value.type === TYPE.Weekly) {\n      if (!this.value.day_of_week_mask) {\n        throw new InvalidPatternError('A day-of-week mask is required for weekly recurrence patterns.');\n      }\n    } else {\n      this.value.day_of_week_mask = null;\n    }\n  }\n\n  _validateInterval() {\n    if (!this.value.interval) {\n      throw new InvalidPatternError('A recurrence interval is required.');\n    }\n    this.value.interval = Number(this.value.interval);\n    if (isNaN(this.value.interval) || this.value.interval <= 0) {\n      throw new InvalidPatternError('The recurrence interval must be a number greater than 0.');\n    }\n  }\n\n  _validateExceptions() {\n    var self = this;\n    this._exceptionsByDate = {};\n    this._exceptionsByOriginalDate = {};\n    this._moved = {};\n    this.value.exceptions = this.value.exceptions || [];\n\n    this._validated = true;\n    var exceptions = {};\n    try {\n      this.value.exceptions.forEach(function(exception) {\n        if (!self.matches(exception.original_date)) {\n          throw new InvalidPatternError('An exception exists for an invalid date \"' + exception.original_date + '\".');\n        }\n        if (exceptions[exception.original_date]) {\n          throw new InvalidPatternError('More than one exception exists for \"' + exception.original_date + '\".');\n        }\n        if (exception.date) {\n          if (\n            exception.date < self.value.start_date ||\n            !!self.value.end_date && exception.date > self.value.end_date\n          ) {\n            throw new InvalidPatternError('The exception for \"' + exception.original_date + '\" is outside the pattern period.');\n          }\n          if (exception.date !== exception.original_date && self.matches(exception.date)) {\n            throw new InvalidPatternError('The exception for \"' + exception.original_date + '\" cannot occur on the same date as a regular occurrence.\"');\n          }\n          if (exceptions[exception.original_date]) {\n            throw new InvalidPatternError('More than one exception exists for \"' + exception.original_date + '\".');\n          }\n          if (exception.date <= self.nextPatternDate(exception.original_date, -1)) {\n            throw new InvalidPatternError('The exception for \"' + exception.original_date + '\" must occur after the previous occurrence.');\n          }\n          if (exception.date >= self.nextPatternDate(exception.original_date, 1)) {\n            throw new InvalidPatternError('The exception for \"' + exception.original_date + '\" must occur before the next occurrence.');\n          }\n        }\n        exceptions[exception.original_date] = true;\n      });\n    } finally {\n      this._validated = false;\n    }\n\n    this.value.exceptions.forEach(function(exception) {\n      self._exceptionsByOriginalDate[exception.original_date] = exception;\n      if (exception.original_date !== exception.date) {\n        self._moved[exception.original_date] = true;\n      }\n      if (exception.date) {\n        self._exceptionsByDate[exception.date] = exception;\n      }\n    });\n  }\n\n  /**\n   * @private\n   * @param {String} date\n   * @returns {Boolean}\n   */\n  _doesOccurWithinPeriod(date) {\n    return (\n      date >= this.value.start_date &&\n      (!this.value.end_date || date <= this.value.end_date)\n    );\n  }\n\n  /**\n   * @private\n   * @param {Date} date\n   * @returns {Boolean}\n   */\n  _doesMatchDayOfWeek(date) {\n    return hasFlag(this.value.day_of_week_mask, getDayOfWeekFlag(date));\n  }\n\n  /**\n   * @private\n   * @param {Date} date\n   * @returns {Boolean}\n   */\n  _doesMatchDailyInterval(date) {\n    var days = durationToDays(date - getDate(this.value.start_date));\n    return days % this.value.interval === 0;\n  }\n\n  /**\n   * @private\n   * @param {Date} date\n   * @returns {Boolean}\n   */\n  _doesMatchWeeklyInterval(date) {\n    var start = getSunday(getDate(this.value.start_date));\n    var end = getSunday(date);\n    var weeks = durationToWeeks(end - start);\n    return weeks % this.value.interval === 0;\n  }\n\n  /**\n   * @private\n   * @param {Date} start The date to start from.\n   * @param {Number} direction A distance multiplier. Must be 1 or -1.\n   * @returns {Date}\n   */\n  _getNextOccurrence(start, direction) {\n    var date = this._snapToOccurrence(start, direction);\n    if (+date !== +start) {\n      return date;\n    }\n    switch (this.value.type) {\n      case TYPE.Daily:\n        return this._getNextDailyOccurrence(date, direction);\n      case TYPE.Weekly:\n        return this._getNextWeeklyOccurrence(date, direction);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Date} date\n   * @param {Number} direction\n   * @returns {Date}\n   */\n  _getNextDailyOccurrence(date, direction) {\n    return plusDays(date, this.value.interval * direction);\n  }\n\n  /**\n   * @private\n   * @param {Date} date\n   * @param {Number} direction\n   * @returns {Date}\n   */\n  _getNextWeeklyOccurrence(date, direction) {\n    do {\n      date = plusDays(date, direction);\n      // If it's Sunday, jump to the next valid week. If the interval is 1,\n      // then we're already there.\n      if (getDayOfWeekFlag(date) === DAYS.Sunday) {\n        date = plusWeeks(date, (this.value.interval - 1) * direction);\n      }\n    } while (!this._doesMatchDayOfWeek(date));\n    return date;\n  }\n\n  /**\n   * @private\n   * @param {Date} date\n   * @param {Number} direction\n   * @returns {Date}\n   */\n  _snapToOccurrence(date, direction) {\n    if (direction > 0) {\n      var patternStart = getDate(this.value.start_date);\n      if (date < patternStart) {\n        date = patternStart;\n      }\n    } else if (this.value.end_date) {\n      var patternEnd = getDate(this.value.end_date);\n      if (date > patternEnd) {\n        date = patternEnd;\n      }\n    }\n    switch (this.value.type) {\n      case TYPE.Daily:\n        return this._snapToDailyOccurrence(date, direction);\n      case TYPE.Weekly:\n        return this._snapToWeeklyOccurrence(date, direction);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Date} date\n   * @param {Number} direction\n   * @returns {Date}\n   */\n  _snapToDailyOccurrence(date, direction) {\n    var start = getDate(this.value.start_date);\n    var remainder = durationToDays(date - start) % this.value.interval;\n    return plusDays(date, remainder * direction);\n  }\n\n  /**\n   * @private\n   * @param {Date} date\n   * @param {Number} direction\n   * @returns {Date}\n   */\n  _snapToWeeklyOccurrence(date, direction) {\n    while (!this._doesMatchDayOfWeek(date)) {\n      date = plusDays(date, direction);\n    }\n\n    var firstDay = getDate(this.value.start_date);\n    while (!this._doesMatchDayOfWeek(firstDay)) {\n      firstDay = plusDays(firstDay, 1);\n    }\n    if (date <= firstDay) {\n      return firstDay;\n    }\n\n    if (this.value.end_date) {\n      var lastDay = getDate(this.value.end_date);\n      while (!this._doesMatchDayOfWeek(lastDay)) {\n        lastDay = plusDays(lastDay, -1);\n      }\n      if (date >= lastDay) {\n        return lastDay;\n      }\n    }\n\n    var remainder = durationToWeeks(getSunday(date) - getSunday(firstDay)) % this.value.interval;\n    if (remainder > 0) {\n      date = plusWeeks(date, remainder * direction);\n      var maskDays = dayOfWeekMaskToArray(this.value.day_of_week_mask);\n      if (direction > 0) {\n        // Starting from Sunday, get the first valid date going forward from\n        // Sunday to Saturday.\n        return plusDays(getSunday(date), maskDays[0]);\n      } else {\n        // Starting from next Sunday, get the first valid date going backward\n        // from Saturday to Sunday.\n        return plusDays(getSunday(plusWeeks(date, 1)), -(7 - maskDays[maskDays.length - 1]));\n      }\n    } else {\n      return date;\n    }\n  }\n};\n\n[\n  'January', 'February', 'March', 'April', 'May', 'June', 'July',\n  'August', 'September', 'October', 'November', 'December'\n].forEach(function(month, index) {\n  Pattern.prototype[month.toLowerCase()] = function(dayOfMonth) {\n    this._validated = false;\n    this.value.month_of_year = index + 1;\n    this.value.day_of_month = dayOfMonth;\n    this.value.instance = null;\n    return this;\n  };\n\n  Pattern.prototype['of' + month] = function(dayOfMonth) {\n    this._validated = false;\n    this.value.month_of_year = index + 1;\n    this.value.day_of_month = dayOfMonth;\n    return this;\n  };\n});\n",
    "/**\n * @enum {Number}\n * Days of the week.\n */\nexport default {\n  Sunday: 1,\n  Monday: 2,\n  Tuesday: 4,\n  Wednesday: 8,\n  Thursday: 16,\n  Friday: 32,\n  Saturday: 64,\n  All: 1 | 2 | 4 | 8 | 16 | 32 | 64,\n  Weekdays: 2 | 4 | 8 | 16 | 32,\n  Weekends: 1 | 64\n};\n",
    "export default class InvalidDateError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'InvalidDateError';\n    this.message = message;\n  }\n};\n",
    "export default class InvalidMaskError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'InvalidMaskError';\n    this.message = message;\n  }\n};\n",
    "export default class InvalidOperationError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'InvalidOperationError';\n    this.message = message;\n  }\n};\n",
    "export default class InvalidPatternError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'InvalidPatternError';\n    this.message = message;\n  }\n};\n",
    "export default class NotSupportedError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'NotSupportedError';\n    this.message = message;\n  }\n};\n",
    "import Pattern from './Pattern';\nimport Mask from './Mask';\nimport days from './days';\nimport type from './type';\n\nimport InvalidDateError from './errors/InvalidDateError';\nimport InvalidMaskError from './errors/InvalidMaskError';\nimport InvalidOperationError from './errors/InvalidOperationError';\nimport InvalidPatternError from './errors/InvalidPatternError';\nimport NotSupportedError from './errors/NotSupportedError';\n\nvar exports = function() {\n  return new Pattern();\n};\n\nexports.Pattern = Pattern;\nexports.Mask = Mask;\nexports.days = days;\nexports.type = type;\n\nexports.errors = {\n  InvalidDateError,\n  InvalidMaskError,\n  InvalidOperationError,\n  InvalidPatternError,\n  NotSupportedError\n};\n\nexport default exports;\n",
    "/**\n * @enum {Number}\n * Recurrence types.\n */\nexport default {\n  Daily: 1,\n  Weekly: 2,\n  Monthly: 3,\n  MonthNth: 4,\n  Yearly: 5,\n  YearNth: 6\n};\n",
    "import InvalidDateError from './errors/InvalidDateError';\n\nconst DATE_PATTERN = /[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}/;\n\n/**\n * @param {String} date\n * @returns {Date}\n */\nexport function getDate(date) {\n  if (!DATE_PATTERN.test(date)) {\n    throw new InvalidDateError('Date \"' + date + '\" is invalid. Expected format to be YYYY-MM-DD.');\n  }\n  var result = new Date(date + 'T00:00:00.000Z');\n  if (isNaN(result.getTime())) {\n    throw new InvalidDateError('Date \"' + date + '\" is invalid.');\n  }\n  return result;\n};\n\n/**\n * @param {String} date\n */\nexport function validateDate(date) {\n  getDate(date);\n};\n\n/**\n * @param {Date} date\n * @returns {String}\n */\nexport function getString(date) {\n  var month = (date.getUTCMonth() + 1).toString();\n  if (month.length === 1) {\n    month = '0' + month;\n  }\n  var day = date.getUTCDate().toString();\n  if (day.length === 1) {\n    day = '0' + day;\n  }\n  return date.getUTCFullYear() + '-' + month + '-' + day;\n};\n\n/**\n * @param {Date} date\n * @returns {Number}\n */\nexport function getDayOfWeek(date) {\n  return date.getUTCDay();\n};\n\n/**\n * @param {Date} date\n * @returns {Number}\n */\nexport function getDayOfWeekFlag(date) {\n  return dayOfWeekToFlag(getDayOfWeek(date));\n};\n\n/**\n * @param {Number} day\n * @returns {Number}\n */\nexport function dayOfWeekToFlag(day) {\n  return Math.pow(2, day);\n};\n\n/**\n * @param {Date} date\n * @returns {Date}\n */\nexport function getSunday(date) {\n  return plusDays(date, -getDayOfWeek(date));\n};\n\n/**\n * Determines whether a given bit mask contains the specified bit flag.\n * @param {Number} mask\n * @param {Number} flag\n * @returns {Boolean}\n */\nexport function hasFlag(mask, flag) {\n  return (mask & flag) === flag;\n};\n\n/**\n * Converts a JavaScript date value to days.\n * @param {Number} value\n *   The number of milliseconds since midnight of Jan 1, 1970 UTC.\n * @returns {Number}\n */\nexport function durationToDays(duration) {\n  return (+duration) / 1000 / 60 / 60 / 24;\n};\n\n/**\n * @param {Number} duration\n * @returns {Number}\n */\nexport function durationToWeeks(duration) {\n  return durationToDays(duration) / 7;\n};\n\n/**\n * @param {Number} days\n * @returns {Number}\n */\nexport function daysToDuration(days) {\n  return days * 24 * 60 * 60 * 1000;\n};\n\n/**\n * @param {Date} date\n * @param {Number} days\n * @returns {Date}\n */\nexport function plusDays(date, days) {\n  return new Date(+date + daysToDuration(days));\n};\n\n/**\n * @param {Date} date\n * @param {Number} weeks\n * @returns {Date}\n */\nexport function plusWeeks(date, weeks) {\n  return plusDays(date, weeks * 7);\n};\n\n/**\n * @param {Number} mask\n * @returns {Array.<Number>}\n */\nexport function dayOfWeekMaskToArray(mask) {\n  var days = [0, 1, 2, 3, 4, 5, 6];\n  var result = [];\n  days.forEach(function(day) {\n    if (hasFlag(mask, dayOfWeekToFlag(day))) {\n      result.push(day);\n    }\n  });\n  return result;\n};\n\nexport function normalizeDirection(direction) {\n  return direction < 0 ? -1 : 1;\n};\n\nexport function extend(target, obj) {\n  var prop;\n  obj = obj || {};\n  for (prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n      target[prop] = obj[prop];\n    }\n  }\n  return target;\n};\n\nexport function find(array, callback) {\n  var index = findIndex(array, callback);\n  if (index > -1) {\n    return array[index];\n  } else {\n    return null;\n  }\n};\n\nexport function findIndex(array, callback) {\n  for (var i = 0; i < array.length; i++) {\n    if (callback(array[i])) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nexport function repeat(string, times) {\n  var ret = '';\n  for (var i = 0; i < times; i++) {\n    ret += string;\n  }\n  return ret;\n};\n"
  ]
}